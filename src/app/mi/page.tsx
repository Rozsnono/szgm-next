"use client";
import QuestionTab from "@/components/questionTab";
import MEMR from "../../txts/memr.json";
import { useQuery } from "react-query";
import { useState } from "react";
import { useRouter } from "next/navigation";

export default function Home() {

    const router = useRouter();

    return (
        <main className="mt-16 mi lg:p-16 p-4 lg:text-lg text-sm text-justify text-gray-900 ">
            <div>
                <h1>MI lufi </h1>
                <p>A tőzsdei lufihoz hasonló jelenség. Egy jelentősebb elért áttörés után különösen megnő az érdeklődés, ezzel együtt a ráfordított erőforrás mennyisége is. Nem feltétlenül sikerült valós piaci körülmények között tartani az ígéreteket. Párszor az MI területén is lezajlott már, pl. 70-80-as évek: visszaesés a kutatási </p>
                <p>támogatásokban, ez volt az MI-tél. A mostani érdeklődést a gépi tanulás alkalmazása váltotta ki, elérhetővé vált kellő mennyiségű és minőségű adat az évtizedekkel korábban kidolgozott megoldások megvalósítására. Jelentős áttörések a robotika, gépi látás, nyelvfeldolgozás területén. Az elmúlt néhány évben megfigyelhető volt egy kisebb visszaesés. Néhány cég nem tudta a kiváló kísérleti eredményeket valós körülmények között is hozni. Az ipar és a befektetők is kezdik látni a technológiai korlátokat, a reális célokat. </p><h1>MI verseny </h1><p>A világ vezetői nagyhatalmai között folytatott verseny a szakterület uralásáért. Vladimir Putin 2017-ben egy tudományos diákfórumon azt mondta: Aki vezetésre tesz szert ezen a területen, az a világ ura lesz.  </p><p>Az országok MI-helyzetét a következők alapján vizsgálják: </p>
                <ul><li>Tudományos közlemények </li><li>Szabadalmak </li><li>Befektetések </li><li>Az MI-re alapozó cégek száma </li></ul>
                <p> </p>
                <p>Minden területen Kína és az Egyesült Államok vezetnek. </p><h1>MI a munkaerőpiaci hatásai </h1><p>Általánosságban: Nem megalapozatlan félelem, hogy az MI az emberek munkahelyeit fenyegeti. A gyárakban már régóta tart az automatizálás, ami csak egyre felgyorsulni látszik, csökkentve az automatizált folyamat által eddig igényelt munkaerőt. A fizikai munkák mellett egyes irodai munkák is automatizálhatók. Új, eddig nem létező munkahelyek is születnek, becslések szerint több munkahely jön majd létre, mint amennyi megszűnik az MI miatt. </p><p>Magyarországon: Becslések szerint a következő 15 évben ~900 ezer munkahelyet érinthet az MI térhódítása. A felforgató hatását a 2030-as évektől várják. </p><p>A legérintettebb szektorok: </p><ul><li>Feldolgozóipar </li><li>Szállítmányozás </li><li>Építőipar </li></ul><p> </p><p>A kétkezi, precíz, monoton feladatok automatizálása okozhatja majd a legnagyobb változást. A korai szakaszokban (2020-as években) várhatóan a nőket, míg később a férfi munkavállalókat fogja jobban érinteni az MI térhódítása. A férfiak által dominált munkakörök érintettsége miatt, várhatóan a férfiakat sokkal inkább befolyásolják majd az MI és az automatizálás hatásai. </p><ul><li>1. Hullám (2020-as évek elejétől): Egyszerű számítási feladatok, strukturált adathalmazok elemzésének, feldolgozásának elvégzése. Pl. pénzügyi, infokommunikációs szektorok </li><li>2. hullám (2020-as évek közepétől): Üzleti támogatási, egyszerű döntéshozatali funkciók elvégzése. Pl. adatbekérő/egyeztető, HR, számviteli funkciók.  </li><li>3. hullám (2030-as évektől): Fizikai, kézi precíziós munkák automatizálása. Pl. összeszerelés, </li></ul><p>szállítmányozás </p><p> </p><p>Informatikában: Az informatikai dolgozókat is fenyegeti az MI, pl: </p><ul><li>Szoftvertesztelés </li><li>Weboldalak készítése (pl. Sketch2Code) </li><li>Szoftverfejlesztés (pl. GitHub Copilot) </li></ul><p> </p><p>Egyéb: Az új, megváltozott feltételekhez kell igazítani a jogrendszert, megfelelő fékek és ellensúlyok szükségesek. Nem hagyhatóak magukra azok, akik elvesztik a munkahelyüket az automatizálás miatt, koncepciók erre: alapjövedelem, a kötelező munkaidő csökkentése. Megnő azon emberek száma, akik korábbi szakmájukat, tudásukat nem tudják hasznosítani, át kell képezzék magukat. Egyre nagyobb szerepet kap az élethosszig tartó tanulás. <strong>Turing teszt teljesítése</strong> </p><p>A számítógépeknek a következő képeségekkel kellene rendelkeznie a Turing teszt teljesítéséhez: </p><ul><li>természetes nyelvfeldolgozásra, a sikeres párbeszédekhez </li><li>tudásreprezentációra, az ismert vagy hallott információ tárolására </li><li>automatizált következtetésre, hogy a tárolt információt kérdések megválaszolására és új következtetések levonására </li><li>gépi tanulásra, az új körülményekhez való adaptálódáshoz, a mintázatok detektálására és általánosítására </li><li>gép látásra, az objektumok érzékeléséhez </li><li>robotikára, az objektumok mozgatásához </li></ul><h1>A mesterséges intelligencia ágai </h1><p>Főbb ágak: </p><ul><li>Látás o Gépi látás o Képfelismerés </li><li>Beszéd o Beszédszintetizálók o Beszédfelismerők </li><li>Természetes nyelvfeldolgozás o Fordítás o Információ kinyerés o Osztályozás/klaszterezés </li><li>Gépi tanulás o Mélytanulás o Prediktív analitika </li><li>Szakértő rendszerek </li><li>Tervezés/Ütemezés/optimalizálás </li><li>Robotika </li></ul><p> </p><h1>A mesterséges intelligencia módszerek szemszögéből </h1><ul><li>Statisztikai módszerek o Nagy revolúció o Statisztikai modellek </li><li>Szimbolikus módszerek o Tradícionális megoldások </li><li>Számítási intelligencia módszerek o Mesterséges neurális hálózatok o Fuzzy rendszerek o Evolúciós algoritmikai módszerek </li></ul><p> </p><h1>A mesterséges intelligencia tipikus problémák szemszögéből </h1><ul><li>Diagnózis o Egy objektum működési hibájának feltárása viselkedése alapján, és megoldások javaslása </li><li>Kiválasztás o A legjobb választás kijelölése egy lehetséges alternatívákat tartalmazó listából </li><li>Jóslás o Egy objektum jövőbeni viselkedésének megjóslása a múltbéli viselkedése alapján </li><li>Osztályozás o Egy objektum hozzárendelése az előre definiált osztályok valamelyikéhez </li><li>Csoportosítás o Objektumok heterogén csoportjának felosztása homogén alcsoportokra </li><li>Optimalizálás o Megoldások minőségének javítása, amíg egy optimális nem áll elő </li><li>Szabályozás o Egy objektum viselkedésének irányítása azzal a céllal, hogy valós időben teljesítse az előírt követelményeket </li></ul><p> </p><h1>Korai MI fejlesztések </h1><ul><li>Formalizmusok, következtetési mechanizmusok, tudásalapú rendszerek (TAR) működtetésére szolgáló eszközök fejlesztése </li><li>Kis TAR megvalósítások </li><li>Különböző megközelítések megvalósíthatóságának vizsgálata </li><li>Ígéretes eredmények ellenére a legtöbb esetben megbuktak a nagyobb méretű TAR fejlesztések </li></ul><p> </p><h1>Szoftverfejlesztés analógia </h1><p>A 1960-as években hasonló folyamat volt megfigyelhető a tradícionális szoftverrendszerek fejlesztésénél </p><ul><li>Szoftver krízis </li><li>A kis akadémiai prototípusokat nem tudták skálázni nagyméretű, karbantartható kereskedelmi rendszerek szintjére </li><li>A szoftverfejlesztés területének megalapításához vezetett </li></ul><p> </p><h1>MI fejlesztés </h1><p>A tudásfejlesztés hasonló a szoftverfejlesztés területéhez </p><ul><li>Cél: TAR fejlesztés mérnöki területté formálása </li><li>Magába foglalja az építési és karbantartási folyamatok vizsgálatát, valamint a megfelelő </li></ul><p>módszertanok, nyelvek és céleszközök fejlesztését a TAR fejlesztéshez </p><p> </p><h1>MI integrálása </h1><ul><li>Az MI fejlesztése önmagában nem elég o Be kell építeni egy olyan szoftver és hardverkörnyezetbe, amely hasznossá teszi </li><li>A rendszerintegrálás speciális változata </li></ul><p> </p><h1>MI fejlesztés: Főbb módszertani megközelítések </h1><ul><li>Átadási folyamat </li><li>Modellezési folyamat </li><li>Adatvezérelt </li></ul><p> </p><h2>Általánosságban az MI fejlesztésről </h2><ul><li>Legfontosabb kérdések a fejlesztés közben: <ul><li>Mi a jó kérdés? o Mi a legjobb megoldás a problémára? o Van adatunk hozzá? o Mennyire fog jól működni? </li><li>Mennyire vihető át a gyártásba? </li></ul></li><li>Szoftver és tervezési korlátok </li><li>Bizonytalanság a problémában és a megoldásban </li><li>Minden iteráció a probléma jobb megértéséhez vezet </li></ul><p> </p><h2>Átadási folyamat </h2><ul><li>Korai 1980-as évek<strong> </strong></li><li>Az emberi tudás átvitele egy implementált tudásbázisba<strong> </strong>o Alap feltevés, hogy a TAR fejlesztéséhez szükséges tudás már létezik és csak be kell gyűjteni<strong> </strong>o Leggyakrabban szakértők interjúján keresztül történik, melynek során feladatokat oldanak meg<strong> </strong></li></ul><p>o Jellemzően a tudást szabályok formájában tárolták, amit egy interpreter dolgozott fel<strong> </strong></p><ul><li>Különböző tudásbázisok alapos vizsgálata kimutatta, hogy a szabályoknál alkalmazott egyetlen reprezentációs formalizmus sem támogatta megfelelően a különböző tudástípusok reprezentálását. A tudásbázisok karbantartása emiatt nehéz és időigényes lett. </li><li>A transzfer megközelítés csak kisméretű, jellemzően prototípus rendszerek fejlesztésére volt alkalmas </li><li>Felismerték, hogy maga az alapfeltevés hibás. Nem csak a meglévő tudás szükséges, fontos a rejtett </li></ul><p>tudás is. </p><p> </p><h2>A tudás/ismeret típusai </h2><ul><li>Explicit - 	Tacit </li><li>Beágyazott </li></ul><p> </p><h1>Waterman – tudástechnológia </h1><ul><li>Tudás alapú rendszerek fejlesztése: Lényegében hasonló folyamatok a modern rendszereknél is - 	6 fázis: </li></ul><p>o Probléma felmérése o Adatok és tudás megszerzése o Prototípus rendszer kifejlesztése o Teljes rendszer kifejlesztése o Rendszer kiértékelése, átdolgozása o Rendszer integrálása, karbantartása </p><ul><li>A fázisok határait esetenként nehéz meghúzni </li><li>Természetes része az állandó iteratív átalakítás </li><li>Kritikus a megfelelő szereplők, adatok és eszközök megválasztása </li><li>Klasszikus MI-k esetén még ma is használható (főként szakértői rendszerek) </li><li>A főbb folyamatok a mai gyakorlatban is jelen vannak, de megjelent az agilis szemlélet. Modern </li></ul><p>megoldások specifikus igényei miatt helyenként eltérhet </p><p> </p><h2>Tudástechnológia: A probléma felmérése </h2><ul><li>A probléma jellege? Milyen típusú a probléma? Pl. Osztályozás, kiválasztás, csoportosítás. Hatással </li></ul><p>van az alkalmazandó erőforrások körére </p><ul><li>Projekt résztvevők? Két kritikus résztvevő: tudásmérnök és területi szakértő.  o A tudásmérnök képes megtervezni, megépíteni és tesztelni egy intelligens rendszert. o A területi szakértő az adott szakterületen széleskörű tudással és kellő tapasztalattal rendelkezik, képes a feladatok megoldására az adott területen. </li><li>Projekt tárgya? Célkitűzés: A versenyelőny, költségek csökkentése, termék/szolgáltatás minőségének a javítása. </li><li>Szükséges erőforrások? Minden, ami a rendszer megépítéséhez szükséges: </li></ul><p>o Hardver infrastruktúra o Szoftver infrastruktúra o Szaktudás és adatforrások o Anyagi fedezet </p><p> </p><h2>Tudástechnológia: Az adatok és a tudás megszerzése </h2><ul><li>Problémakör jobb megismerése: Adatok begyűjtése, elemzése, új ismeretek szerzése </li><li>Rendszer tervének pontosítása az új ismeretek alapján </li><li>Az adatok gyakran heterogén forrásból származnak: Minőség, felépítés eltérhet. Szükség lehet az adatok kondicionálására </li><li>Az alkalmazott eszközöktől függően eltérő jellegű adatokra van szükség </li><li>Az adatok begyűjtése során is keletkezhet új ismeret o Ismeretszerzés: Iteratív folyamat. A területhez kapcsolódó szakirodalom megismerése. Alaposabb megértés érdekében szakértői interjúk </li><li>Meghatározható absztrakt szintű megoldási stratégia - 	A prototípusnál használandó eszközök kiválaszthatók - 	Tipikus problémák a beszerzett adatokkal: <ul><li>Inkompatibilis adatok: A különböző forrásból származó adatok kódolása eltérhet. Az adatforrás és a feldolgozáshoz használt eszköz által elvárt kódolás eltérhet. Az adatok transzformációja nagy körültekintést igényel. o Inkonzisztens adatok: Nem összefüggő adatok. Az adatforrások eltérő tartalmú adatokból állnak. Az adatforrások eltérő pontosságúak. </li><li>Hiányos adatok:  <ul><li>Üres adatmezők. Sérült, mulasztás miatt hiányzó adatok. </li><li>Kezelhető: Elvetjük a hiányos rekordokat. Pótoljuk a hiányzó adatmezőket. </li></ul></li></ul></li></ul><p><strong> </strong></p><h2>Tudástechnológia: Prototípus rendszer kifejlesztése </h2><ul><li>Ez már önmagában is egy intelligens rendszer létrehozása </li><li>A teljes rendszer kicsiben megépített változata </li><li>Kimondottan a probléma megértésének, a koncepció és a megoldás tesztelése a cél </li><li>Szükség lehet szakértő bevonására </li><li>A különböző megoldások eltérő tesztelési stratégiát kívánnak meg </li><li>A tesztesetek általában már megoldott esetek adatait tartalmazzák </li><li>Előfordulhat, hogy teljesen új alapokra épített prototípust kell fejleszteni az eredmények alapján, ez </li></ul><p>természetes folyamat. </p><p> </p><h2>Tudástechnológia: A teljes rendszer kifejlesztése </h2><ul><li>A prototípus rendszer fejlesztése során szerzett tapasztalatok alapján - 	Főbb lépései: <ul><li>Tervezés o Ütemezés </li><li>Költségvetés elkészítése o Teljesítmény kritériumok definiálása - 	Újabb adatokkal és ismeretekkel kell bővíteni a rendszert </li></ul></li><li>Megfelelő interfészek kialakítása </li></ul><p> </p><h2>Tudástechnológia: A rendszer kiértékelése és átdolgozása </h2><ul><li>A klasszikus rendszerekkel szemben nem jól definiálhatók a problémák és megoldásuk </li><li>A kiértékelés a szoftver céloknak való megfelelőség ellenőrzése </li><li>Formális kiértékelés jellemzően minta adatok alapján: Az elfogadási kritériumok a prototípus fejlesztésének végén kerülnek meghatározásra. Ha az eredmények nem elfogadhatók, a rendszer teljes revíziójára lehet szükség. </li></ul><p> </p><h2>Tudástechnológia: A rendszer integrálása és karbantartása </h2><ul><li>A fejlesztési ciklus végső fázisa </li><li>Szoftver-környezetbe való illesztés </li><li>Karbantartási program </li><li>A felhasználó számára biztosítani kell a rendszer üzemeltethetőségét és karbantarthatóságát  </li></ul><p> </p><h2>Modellezési folyamat </h2><ul><li>A TAR építés modellezési tevékenységnek is tekinthető </li><li>Olyan számítógépes modell létrehozása, melynek célja olyan problémamegoldási képesség megvalósítása, ami felér a terület szakértőjével </li><li>Nem az a cél, hogy lemásolja a szakértő kognitív folyamatait, hanem hogy olyan modellt hozzunk létre, ami hasonló eredményeket hoz </li><li>A szakértő tudása lehet rejtett, amit nem tud megfogalmazni, így nem érhető el közvetlenül, de a </li></ul><p>tudás beszerzése során építeni kell rá </p><p> </p><ul><li>A modellezési szemlélet következményei: <ul><li>Egy modell csak a valóság egy megközelítése o A modellezés ciklikus folyamat </li><li>A modellezés függ a tudásmérnök személyes értelmezésétől </li></ul></li></ul><p> </p><ul><li>A modellezési szemlélet jellemzői: <ul><li>A rendszer mély ismerete szükséges o Nem lehet végtelen komplexitást kezelni o Költséges és időigényes </li></ul></li></ul><p> </p><h2>Adatvezérelt folyamat </h2><ul><li>Jellemzően gépi tanulás módszerek: Olyan rendszer építése, ami minta esetek alapján próbál megfelelő megoldást találni </li><li>Nagy mennyiségű adat szükséges: Big Data, dolgoznak rajta hogy ez csökkenthető legyen, de nem minden esetben megvalósítható </li><li>Számos módon megvalósítható: Leggyakoribb a neurális hálók </li><li>Előnye, hogy nem kell szakértő által megfogalmazott tudást formalizálni </li></ul><p> </p><h1>Gépi tanulás életciklusa </h1><ul><li>Projekt célkitűzésének definiálása o Üzleti cél meghatározása o Területi szakértelem gyűjtése o Modell kritériumok rangsorolása <ul><li>Megvalósíthatóság, kockázatok és siker kritériumok </li></ul></li></ul><p>Döntés a folytatásról </p><ul><li>Adatok felkutatása és begyűjtése o Megfelelő adat felkutatása o Feltáró adatelemzés végrehajtása o Hiányosságok feltárása és pótlása o Feature engineering </li><li>Adat modellezése o Változók kiválasztása <ul><li>Különböző modell-jelöltek kialakítása </li><li>Modellek validációja és a megfelelő kiválasztása </li></ul></li><li>Adatok feldolgozása és közlése o Modell értelmezése <ul><li>A modellben feltártak átadása </li></ul></li><li>Implementálás, dokumentálás, karbantartás o A modellt alkalmazó rendszer implementálása o A modellezési folyamat dokumentálása <ul><li>Modell megfigyelési és karbantartási rendszer kidolgozása </li></ul></li></ul><p> </p><h1>MI tesztelési életciklus </h1><ul><li>Követelmény elemzés </li><li>Teszt tervezés </li><li>Tesztek kidolgozása, adatok előkészítése </li><li>Teszt végrehajtása </li><li>Tesztelési ciklus zárása </li></ul><p> </p><h1>CRISP-DM </h1><p>Cross-industry standard process for data mining </p><ul><li>Egyik leggyakrabban használt módszertan, ami iránytűként szolgál abban, hogy lehet egy üzletileg sikeres adatelemzési projektet véghez vinni. </li><li>A sikerhez számos komponensre van szükség: <ul><li>Mi a valós cél, aminek elérésében az adatelemzés segítséget nyújthat? </li><li>Hogyan lehet a fenti üzleti célt adatelemzési céllá fordítani? o Milyen adatok állnak rendelkezésre az elemzés létrehozásához? </li><li>Hogyan kell ezeket az adatokat felhasználni a leghatékonyabb és üzletileg is sikeres megoldás kialakításához? </li><li>Milyen modellezési technikákat érdemes a cél elérése érdekében használni? o Hogyan lehet egy adatelemzési megoldást üzletileg kiértékelni? o Hogyan lehet a megoldást felhasználni az üzleti folyamatokban? </li></ul></li></ul><p> </p><ul><li>6 fő fázisa: <ul><li>Üzleti célok meghatározása o Adatok megértése o Adatok előkészítése o Modellezés o Üzleti kiértékelés o Hadrendbe állítás </li></ul></li></ul><p> </p><h1>MI fejlesztéshez használt népszerű szoftverek </h1><ul><li>Caffe o Eredetileg a Berkeley egyetemen fejlesztett Mélytanulási keretrendszer o Népszerű mert: nagy sebességű, GPU alapú számítások támogatása, gyakori modellek támogatása <ul><li>Caffe2: Továbbfejlesztett változat, a Facebook adta ki, 2018-ban a PyTorch-ba olvasztották </li></ul></li></ul><p> </p><ul><li>PyTorch o Python alapú o Tudományos számítási csomag o Két célközönség: GPU alapú számítások, mélytanulási kutatások. </li></ul><p> </p><ul><li>TensorFlow <ul><li>Google által fejlesztett </li><li>Bonyolult numerikus számítások kezelésére alkalmas programkönyvtár o Egyaránt alkalmas kutatásra és termékfejlesztésre o Közkedvelt a gépi tanulás kutatók és fejlesztők között </li></ul></li></ul><p> </p><ul><li>Cognitive Toolkit <ul><li>Microsoft által fejlesztett o Nyíltforráskódú mélytanulási eszköztár </li><li>Kereskedelmi színvonalú fejlesztésekhez </li></ul></li></ul><p> </p><ul><li>Keras o Python alapú o Nyílt forráskódú <ul><li>Neurális hálózat programkönyvtár </li><li>Képes együttműködni más népszerű könyvtárakkal Pl. TensorFlow, Cognitive Toolkit </li></ul></li></ul><p> </p><ul><li>DeepLearning4j o Java alapú <ul><li>Mélytanulási programkönytár </li></ul></li></ul><p> </p><ul><li>Jupyter Notebook o Nyílt forráskódú o Web alapú alkalmazás <ul><li>Lehetővé teszi olyan dokumentumok létrehozását, amelyek élő forráskódot és egyéb elemeket tartalmaznak </li></ul></li></ul><p> </p><ul><li>NLP Architect <ul><li>Intel által fejlesztett o Python alapú o Nyílt forráskódú </li><li>Korszerű mélytanulási módszerek érhetőek el Pl. természetes nyelvfeldolgozás </li></ul></li></ul><p> </p><ul><li>Weka o Ingyenes o Nyílt forráskódú o Gép tanulási szoftver <ul><li>Számos adatbányászati feladat megoldására szolgáló algoritmust tartalmazó gyűjtemény o Lehetőséget nyújt többek között az adatok előkészítésére, regressziós, valamint klaszterezési feladatokra is. </li></ul></li></ul><p> </p><ul><li>OpenCV <ul><li>Nyílt forráskódú </li><li>Akadémiai és kereskedelmi célra egyaránt ingyenesen használható o Gépi látás és gépi tanulási programkönyvtár </li></ul></li></ul><p>Több programozási nyelvet támogat Pl. C++, Java, Python o Több platformot támogat Pl. Windows, MacOS, iOS, Android </p><p> </p><ul><li>R <ul><li><ul><li>Nyílt forráskódú </li><li>Általános célú adatelemzésre szolgáló szoftverkörnyezet o Több operációs rendszeren is fut o Használják a gépi tanulás területén </li></ul></li></ul></li></ul><p> </p><h1>MI szolgáltatások </h1><ul><li>A komoly MI megoldások gyakran igényelnek jelentős hardverinfrastruktúrát. Ez számos kihívást jelent: <ul><li>Az eszközök költségesek o Megfelelő helyet kell találni az üzemeltetéshez o A karbantartás komoly erőforrásokat köt le o Megoldás lehet a felhő alapú technológia </li></ul></li><li>A tech óriások számos felhő alapú MI szolgáltatást biztosítanak: <ul><li>Google <ul><li>Számos szolgáltatás Pl. Gépi tanulás, nyelvfeldolgozás, gépi látás területén </li><li>Google Colab: Ingyenes, GPU használat lehetséges, saját MI projektek valósíthatóak meg </li></ul></li><li>Microsoft <ul><li>Azure szolgáltatásába integrált: Főként gépi látás, beszédfelismerés és gépi fordítás területekre fókuszál o IBM </li><li>IBM Watson: Természetes nyelvfeldolgozási módszereket alkalmaz. Felhő alapú </li></ul></li></ul></li></ul><p>szolgáltatás, gépi fordításokon túl különböző nyelvi elemzéseket is lehetővé tesz </p><p> </p><h1>MI megoldást futtató hardver </h1><ul><li>Lényegében a feldolgozó egység </li><li>Két fő típus: <ul><li>On-device: CPU, FPGA, ASIC, GPU </li><li>Cloud </li></ul></li><li>A valóságban ez sokkal bonyolultabb témaköröket érint: On-premises, Edge devices, Fog computing </li></ul><p> </p><ul><li>CPU: bonyolult számítások gyorsan, de kevés párhuzamos szál </li></ul><p> </p><ul><li>GPU:  <ul><li>egyszerűbb számítások nem túl gyorsan, de rengeteg párhuzamos szál o nVidia előnyben a CUDA-val, az AMD hátrányban az OpenCL-el </li></ul></li></ul><p> </p><ul><li>FPGA:  <ul><li>Field Programmable Gate Array o Robosztikus rendszer hozható létre egy chipen </li><li>Különböző funkcióval rendelkező blokkok hozhatók létre </li></ul></li></ul><p> </p><ul><li>ASIC: Application Specific Integrated Chips o Hasonló az FPGA-hoz, de nem módosítható o Masszív párhuzamosítás </li></ul><p> </p><ul><li>SoC: System-on-Chip </li></ul><p> </p><ul><li>Quantum számítógép: a jövő zenéje, de hatalmas jelentősége lenne a gépi tanulásban </li></ul><p> </p><p> </p><p> </p><h1>Beavatkozó hardverek </h1><ul><li>Elektromos beavatkozók o Villanymotorok: egyenáramú szervómotorok, váltóáramú motorok, léptetőmotorok o Solenoidok - 	Hidraulikus beavatkozók </li><li>Pneumatikus beavatkozók </li><li>Léptető motor - 	Servo motor </li><li>Motorvezérlők </li></ul><p> </p><ul><li>Érzékelők főbb típusai: látás/képalkotás, hőmérséklet, sugárzás, távolság, nyomás, pozíció, részecske, mozgás, fém, szint, szivárgás, páratartalom, gáz és vegyianyag, erő, áramlás, anyagok felületi és felszín alatti hibái, láng, elektromosság </li></ul><p> </p><h1>Fuzzy </h1><h2>Logikák </h2><p>2 értékű logikák: Igaz/hamis, Boole foglalta axiomatikus rendszerbe </p><p>¾ értékű logikák: Megjelennek új értékek eldöntetlen, eldönthetetlen </p><p>Fuzzy logika: Lofti Zadeh – 1965, végtelen értékű logika, a Boole logika általánosítása. Részleges igazságot is megenged, egy állítás nem csak igaz vagy hamis lehet, hanem többé-kevésbé igaz </p><p> </p><h2>CRISP halmaz </h2><p>Ha A halmaz minden eleme B halmaznak is eleme, akkor A és B részhalmaza, amit A ⊂ B-vel vagy A ⊆ Bvel jelölünk, ez utóbbi esetben kihangsúlyozza azt, hogy egyenlőség is megengedett.  Hatványhalmaz: Egy A halmaz összes részhalmazának halmazát, P(A)-t, az A hatvány halmazának hívjuk. A véges A halmaz elemeinek számát |A| jelöli. Ha A véges, akkor |P(A)| = 2<sup>|A| </sup></p><p>Komplemens: Az A halmaz komplemense, az alaphalmaz A-ban nem szereplő elemeit tartalmazza. </p><p>Únió: A és B halmazok egyesítése, más szóval úniója, A ∪ B, azon elemeket tartalmazza, melyek legalább vagy az A vagy a B halmaznak eleme. </p><p>Metszet: A és B halmazok metszete, A ∩ B, azon elemeket tartalmazza, melyek mind az A, mind a B halmaznak elemei. </p><p>Tagsági függvény: Valamely CRISP alaphalmaz minden eleméhez az értékkészletéből egy tagsági értéket rendel. </p><h2>Fuzzy halmazok változatai </h2><ul><li>Vektor értékű </li><li>Intervallum értékű </li><li>2-es típusú </li></ul><p> </p><p><strong>Fuzzy halmazok tulajdonságai </strong>α-vágat: ? </p><p>Szigorú α-vágat: ? </p><p>Magasság: Tagsági függvény legnagyobb értéke </p><p>Tartó: Valamely A fuzzy halmaznak az alaphalmaz 0-nál nagyobb tagsági értékű pontjainak összessége. </p><p>Mag: Valamely A fuzzy halmaz magján az alaphalmaz 1 tagsági értékkel rendelkező pontjainak összességét értjük. </p><p>Az A fuzzy halmaz normális, ha h(A) = 1. Az A fuzzy halmaz szubnormális, ha h(A)&lt;1. </p><p>Konvexitás: Valamely A fuzzy halmaz konvex, ha valamennyi α <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAeCAYAAAAy2w7YAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAAERSURBVEhLvZYxDgFREIYXFxBuoFPpRKFRSZzAhVxAoVIqdNp1BeIGVqLTUFLy/8m8ZEx2I2vn7Zd8ptk1OzPv7b6kLhoSfzGAIziBbTiFZdhLLGQMU/iuKP+jkAXMu+kfCxOtoL14C+eQVbpgKzlCzsgVPq1O8oBd6I4d/Ay6w/boJGyZG02JxO6NtUR3bNvcF0CAg9eJoqGTuM6HhBn1JAbuEt2x+8fbVK+6qNSWKMAZfZUKXQkVXSTWQtR9pGd0kBiwS74SOtFOYmAo0Z3oC0JjX6xun21LbV9YYs8MZxitMr69dTLKtrqeggjbZedVxbSFnzxecANvsA87sApZUaLACS4hW3mFT8jzesnESfYB7PyfktsKLecAAAAASUVORK5CYII=" /> (0,1] vágata a hagyományos értelemben véve konvex. </p><p> </p><p><strong>Fuzzy műveletek </strong>Fuzzy komplemens: Fuzzy komplemensnek nevezzük a c: [0,1] → [0,1] függvényt, amely minden A(x) tagsági függvény-értékhez tetszőleges A fuzzy halmaz esetén a c(A(x)) értéket rendeli hozzá olyan módon, hogy teljesüljön a fuzzy komplemens axiomatikus váza, c1 és c2 axiómák. </p><p>Fuzzy metszetek: Általánosan az A és B fuzzy halmazok metszetét az egységnégyzeten való bináris operátorként adhatjuk meg. t: [0,1] x [0,1] → [0,1] </p><p>Fuzzy úniók: Általánosan az A és B fuzzy halmazok únióját az egységnégyzeten való bináris operátorként adhatjuk meg. s: [0,1] x [0,1] → [0,1] CRISP, Fuzzy partíciók? </p><p> </p><h2>Relációk </h2><p>A hagyományos relációk két vagy több halmaz elemei közötti összefüggést, kapcsolatot vagy éppen annak hiányát fejezik ki. Ennek alapján két (vagy több) halmaz béli elem vagy relációban van egymással, vagy nem. Az X1,X2, . . . ,Xn halmazok közötti R relációt úgy definiáljuk, mint a reláció alaphalmazai DESCARTES-szorzatának részhalmazát. </p><p>Fuzzy reláció: A halmaz elemei közötti kapcsolat 0 és 1 közötti mértékét is modellezhetjük. </p><p> </p><h1>Logikai ágensek </h1><h2>Tudásbázisú ágensek </h2><ul><li>A tudás reprezentációja és a tudás alkalmazását lehetővé tevő következtetési folyamatok  </li><li>A tudás és a következtetés alapvető szerepet játszanak a részben megfigyelhető környezetek kezelésénél is Pl. orvos diagnosztizál egy beteget </li><li>Rugalmasság: Képesek explicit célok formájában megadott új feladatokat elfogadni. Egy új környezetről kapott vagy megtanult új ismeretek révén kompetenssé válni. Frissítve a tudásuk releváns részét képesek alkalmazkodni a környezet változásához. </li><li>Központi eleme a tudásbázisa (knowledge base)  </li><li>A tudásbázis mondatok (sentences) halmaza </li><li>A mondatokat egy nyelv segítségével fejezzük ki, amelyet tudásreprezentációs nyelvnek (knowledge representation language) nevezünk, és a világról szóló állításokat fogalmazunk meg vele </li></ul><p>Tudásbázis: Kezdetben bizonyos háttértudást tartalmazhat </p><p>Új mondatok a tudásbázishoz való hozzáadására és a tudás lekérdezésére szükség van valamilyen eljárásra, mindkettő feladat tartalmazhat következtetést <strong>Wumpus világ leírása (faszság az egész) </strong>- 	Teljesítménymérték o +1000 az arany felvétele </p><ul><li><ul><li>-1000 a csapdába esés, vagy ha a wumpus felfal o -1 minden végrehajtott cselekvés, -10 a nyíl használata </li></ul></li><li>Környezet: Egy szobákból álló 4x4-es háló o [1, 1]-gyel jelölt négyzetből indul, arccal jobbra nézve <ul><li>Az arany és a wumpus elhelyezkedése véletlenszerűen, a kiinduló négyzeten kívüli négyzetek közül egyenletes eloszlás szerint van megválasztva </li><li>Bármely, a kiinduló négyzeten kívüli négyzet 0,2 valószínűséggel lehet csapda - Cselekvések </li></ul></li><li>Érzékelők </li></ul><p> </p><h2>Modellellenőrzés jellemzői </h2><ul><li>Helyes vagy igazságtartó: Csak vonzat mondatokat vezet le </li><li>Teljesség: Egy következtetési eljárás teljes, ha képes levezetni minden vonzatmondatot. </li></ul><p> </p><h2>Ítéletkalkulus </h2><p>Szintaxis: Az atomi mondatok oszthatatlan szintaktikai elemek egyetlen ítéletszimbólumból állnak. Minden ilyen szimbólum egy kijelentés, ami igaz vagy hamis lehet. Nagybetűs neveket használunk a szimbólumok jelölésére. Létezik két ítéletszimbólum, amelyeknek a rögzített értelmezése: az Igaz egy mindig igaz állítás és a Hamis egy mindig hamis állítás. Összetett mondatok létrehozhatók egyszerűbb mondatokból logikai összekötőjelek felhasználásával. </p><p>5 használt összekötőjel van: </p><ul><li>negáció </li><li>konjunkció </li><li>diszjunkció </li><li>implikáció </li><li>ekvivalencia  </li></ul><p> </p><p>Az ítéletkalkulusban a modell egyszerűen az igazságértéket (igaz vagy hamis) rögzíti minden ítéletszimbólumra. Az ítéletszimbólumnak az igazságértéket közvetlenül a modellben kell meghatározni. Minden összekötőjelre vonatkozó szabály összefoglalható egy igazságtáblában, amely meghatározza egy összetett mondat igazságértékét a mondat komponenseinek minden lehetséges igazságérték hozzárendeléseihez. </p><p>Vonzattal kapcsolatos fogalmak </p><p>Logikai ekvivalencia: Két mondat az α és a β mondatok logikailag ekvivalensek, ha ezek a mondatok a modellek ugyanazon halmazán igazak. </p><p>Érvényesség: Egy mondat érvényes, ha igaz minden modellben. </p><p>Kielégíthetőség: Egy mondat kielégíthető, ha igaz néhány modellben. </p><h2>Előrefelé láncolás </h2><p>Az algoritmus meghatározza, hogy egy q ítéletkalkulus szimbólum a lekérdezés vonzata-e egy Hornklózokat tartalmazó tudásbázisnak. Az algoritmus a tudásbázisban található ismert tényekből indul ki. Ha egy implikáció minden előtagja ismert, akkor az utótagját hozzáadjuk az ismert tények halmazához. A folyamat megáll, ha: a kérdésben szereplő állításparamétert hozzá tudjuk adni az ismert tények halmazához, ha már nem tudunk további következtetéseket végrehajtani. Lineáris időben fut. </p><h2>Hátrafelé láncolás </h2><p>A lekérdezésekből kiindulva működik. Az algoritmus megtalál minden olyan implikációt a tudásbázisban. amelynek következménye a lekérdezésben szereplő állításparaméter. Ha valamelyik ilyen implikációnak az összes előtagját be lehet bizonyítani, akkor a lekérdezésben szereplő állításparaméter igaz.  </p><p>Egy ágensnek meg kell osztania a munkát az előrefelé és a hátrafelé láncolás között. Korlátozni kell az előrefelé láncolást a releváns tényekre. A releváns tények hátrafelé láncolás útján derülhetnek ki.  </p><h2>DDPL algoritmus </h2><p>Három szinten fejleszti tovább az algoritmust: </p><ol><li>Korai leállás: Az algoritmus észreveszi, hogy egy adott mondat már biztosan igaz vagy hamis még részben elkészült modell alapján is. Egy klóz igaz, ha bármelyik literál igaz. Ha bármelyik klóz hamis, akkor a formula is hamis. A korai leállás a keresési tér egész részfáinak átvizsgálását kerüli el. </li></ol><p> </p><ol><li>Tiszta szimbólum heurisztika: Egy olyan szimbólum, amely mindig ugyanolyan előjellel szerepel minden klózban. Ha egy mondatnak van modellje, akkor létezik tiszta szimbólumokat tartalmazó modellje is, amelyben a tiszta szimbólumok értéke úgy van megválasztva, hogy literáljai igazak legyenek, hiszen így egyetlen klózt sem teszünk hamissá. Egy szimbólum tisztaság tulajdonságának meghatározásakor az algoritmus figyelmen kívül hagyhatja azokat a klózokat, amelyekről már tudjuk hogy igazak a modell eddigi konstruálása alapján. </li></ol><p> </p><ol><li>Egységklóz heurisztika: Az egységklóz olyan klóz, amelynek egy literálja van. DPLL esetén ez azokat a klózokat is jelenti, hogy egy kivételével minden literál hamis értéketkapott a modellben. Értéket adva egy egységklózhoz újabb egységklózt hozhatunk létre. </li></ol><p> </p><h2>WALKSTAT algoritmus </h2><ul><li>Minden iterációban az algoritmus vesz egy kielégítetlen klózt és egy szimbólumot a klózból, amelynek értékét ellenkezőre cseréli. </li><li>Az értéket cserélő szimbólum kiválasztása a következő két módszer közül véletlenszerűen választva az egyikkel történik: </li></ul><p>o Min-konfliktus lépés: Minimalizálja a kielégítetlen klózokat az új állapotban o Véletlen-bejárás: Véletlenszerűen választja a szimbólumot. </p><p> </p><h2>Ítéletlogikát alkalmazó ágensek </h2><ul><li>Következtetésalapú ágens: Következtetési algoritmusokat használ a világ eseményeinek követésére és képes rejtett jellemzőket is levezetni. </li><li>Áramkörön alapuló ágens: Az állításokat regiszterek bitjeiként reprezentálja és jelek logikai </li></ul><p>áramkörökben történő terjesztésével végzi ezek frissítését. </p><p> </p><h1>Ágens </h1><p>Egy ágens nem más, mint valami, ami cselekszik. Egy ágens bármi lehet, amit úgy tekinthetünk, mint ami az érzékelői segítségével érzékeli a környezetét és beavatkozói segítségével megváltoztatja azt. Pl. emberi ágens, robot ágens, szoftverágens. </p><p>Érzékelés: Ezt a fogalmat használjuk az ágens érzékelő bemeneteinek leírására egy tetszőleges pillanatban. </p><p>Érzékelési sorozat: Az ágens érzékeléseinek teljes története, minden, amit az ágens valaha is érzékelt. Ágensfüggvény: Az ágens viselkedését írja le, az adott érzékelési sorozatot egy cselekvésre képezi le. </p><p>Ágensprogram: Ez valósítja meg az ágensfüggvényt az ágens belsejében, az ágens architektúráján működik. </p><p><strong>Racionális ágens </strong>Olyan ágens, amely a tudásához viszonyítva helyesen cselekszik, elméletileg megfogalmazva az ágensfüggvény táblázatában minden bejegyzés helyesen van kitöltve. Szükség van az ágens sikerességének mérésére, ez a teljesítménymérték. A teljesítménymérték értékeli az ágens viselkedését a környezetben. A racionalitás az elvárt teljesítményt maximalizálja, míg a tökéletesség a tényleges teljesítményt. </p><h2>Fogalmak </h2><p>Információgyűjtés: Hasznos információk beszerzése érdekében véghez vitt cselekedetek. </p><p>Felfedezés: Ismeretlen környezet feltérképezése. </p><p>Tanulás: Az ágens tanul a megfigyeléseiből. </p><p>Nem autonóm ágens: A tervezői által beépített tudásra épít és nem saját megfigyeléseire. </p><h2>Feladatkörnyezet </h2><p>Ágenstervezés első lépése: Feladatkörnyezet lehető legteljesebb leírása. </p><p>Tartalmazza a teljesítményérték, a külső környezet, a beavatkozók és a szenzorok meghatározását. </p><ul><li>Teljesítmény </li><li>Környezet </li><li>Beavatkozók </li><li>Érzékelők </li></ul><p> </p><h2>Környezet tulajdonságai, kategorizálása </h2><ul><li>Teljesen megfigyelhető: Ha az ágens szenzorjai minden pillanatban hozzáférést nyújtanak a környezet teljes állapotához. </li><li>Részlegesen megfigyelhető: Zajos és pontatlan szenzorok miatt, vagy mivel az állapot egyes részei egyszerűen nem szerepelnek a szenzorok adatai között. </li><li>Determinisztikus: Amennyiben a környezet a következő állapotát a jelenlegi állapota és az ágens által végrehajtott cselekvés teljesen meghatározza. </li><li>Sztochasztikus: Nem determinisztikus </li><li>Stratégiai: Ha a környezet más ágensek cselekvéseit leszámítva determinisztikus. </li><li>Epizódszerű: Minden egyes epizód az ágens észleléseiből és egy cselekvéséből áll. A következő epizód nem függ az előzőekben végrehajtott cselekvésektől. </li><li>Sorozatszerű: A rövid távú akciók hosszú távú következményekkel járhatnak. </li><li>Dinamikus: Ha a környezet megváltozhat, amíg az ágens gondolkodik. </li><li>Statikus: Nem dinamikus, nem kell az idő múlásával törődni. </li><li>Szemidinamikus: Ha a környezet nem változik az idő előrehaladtával, de az ágens teljesítménymértéke igen. </li><li>Diszkrét vagy folytonos: Környezet állapotára, az időkezelés módjára, ágens észlelésére és </li></ul><p>cselekvéseire. </p><p> </p><p>Ágensek száma szerint: </p><ul><li>Egyágenses </li><li>Többágenses </li></ul><h1>Ágensprogram </h1><p>Ágens = architektúra + ágensprogram </p><p>Architektúra: Valamilyen fizikai érzékelőkkel és beavatkozókkal ellátott számítóeszköz. Az architektúra a szenzoroktól érkező észleléseket elérhetővé teszi a program számára, futtatja a programot, és cselekvéseit létrejöttük pillanatában a beavatkozók felé továbbítja. </p><h2>Táblázat vezérelt ágenstervezés </h2><ul><li>Minden új észlelésre meghívódik, és minden alkalommal visszaad egy cselekvést. </li><li>Alkalmazásának korlátja a táblázat nagy mérete: Egyetlen kamerától érkező vizuális bemenet körülbelül 27 MB/mp sebességgel érkezik </li><li>Sakkhoz tartozó táblázat legalább 10<sup>150</sup> bejegyzést tartalmaz </li><li>Ezen táblázatok mérete azt jelenti, hogy ebben az univerzumban egyetlen fizikai ágensnek sem lesz elég helye a táblázat tárolására. A tervezőnek nem lenne elég ideje a táblázat elkészítéséhez. Egyetlen ágens sem lenne képes a táblázat helyes bejegyzéseit megtanulni saját tapasztalatból, még ha a környezet eléggé egyszerű is egy megvalósítható méretű táblázathoz, a tervezőnek még akkor sincs segítsége ahhoz, hogyan töltse ki a táblázat bejegyzéseit. </li><li>A mesterséges intelligencia feladata, olyan program írása, amely nagyszámú táblázatbejegyzések helyett kisméretű programkóddal produkál racionális viselkedést. <strong>Ágensprogram típusok </strong></li><li>Egyszerű reflex szerű ágensek o Legegyszerűbb fajtájú ágens <ul><li>Az aktuális észlelés alapján választják ki a cselekvéseket, figyelmen kívül hagyva az észlelési történet többi részét </li><li>Feltétel-cselekvés szabályokat tartalmaz, Pl. ha az előző autó fékez akkor kezdj fékezni o Csak akkor fog működni, ha a helyes döntés kizárólag az aktuális észlelés alapján meghozható, azaz, ha a környezet teljesen megfigyelhető </li></ul></li><li>Modellalapú reflex szerű ágensek o Nyomon követi a világ jelenlegi állapotát egy belső modellben. Ezek után a reflex szerű ágenshez hasonlóan választ egy cselekvést <ul><li>Részleges megfigyelhetőség kezelésére irányul </li><li>Nyilvántart valamiféle belső állapotot, amely az észlelési történeten alapul, Pl. sávváltáshoz, az ágensnek nyomon kell követnie hol tartózkodik a többi autó, amennyiben nem látja mindegyiket egyszerre </li></ul></li><li>Modellalapú célorientált ágensek o Nyomon követi a világ állapotát és az elérendő célok halmazát is, és kiválaszt egy cselekvést, amely céljainak eléréséhez vezet <ul><li>A célorientált cselekvés kiválasztása egyszerű, amikor a cél teljesülése azonnal egyetlen cselekvéssel elérhető </li><li>Reflex szerű ágenseknél rugalmasabb a cél elérésében </li></ul></li><li>Hasznosságorientált ágensek o Olyan cselekvést választ, amely a legjobb várható hasznossághoz vezet. <ul><li>Adott elérendő cél meghatározása gyakran nem elegendő jó minőségű viselkedés létrehozásához. Pl. Többféle cselekvéssorozat vezet a taxi végállomásának és így a céljának az eléréséhez, de némelyik gyorsabb, biztonságosabb, megbízhatóbb vagy olcsóbb, mint mások. o A világ egyik állapota előnyösebb egy másikhoz képest, ha nagyobb a hasznossága az ágens számára. </li><li>A hasznosságfüggvény egy állapotot egy olyan valós számra képezi le, amelyik a hozzá rendelt boldogság fokát írja le. </li><li>A hasznosságfüggvény teljes meghatározása kétféle olyan helyzetben tesz lehetővé racionális döntéseket, amikor a célok erre alkalmatlanok. Amikor egymásnak ellentmondó célok vannak, amelyeknek csak egy része érhető el, akkor a hasznosságfüggvény meghatározza a helyes kompromisszumot. Amikor több cél van, amelyek elérésére az ágens törekedhet, és egyikük sem érhető el teljes bizonyossággal, a hasznosság olyan módszert ad, amivel a siker valószínűsége a célok fontosságához mérhető. </li></ul></li></ul><p> </p><h2>Tanuló ágensek </h2><p>Négy koncepcionális komponensre bontható: </p><ul><li>Végrehajtó elem: Eddig a teljes ágensnek tekintettük, ez végzi az észleléseket és ez dönt a cselekvésekről. </li><li>Kritikus: Megmondja a tanuló elemnek, hogy az ágens milyen jól működik egy rögzített teljesítményszabványhoz viszonyítva. </li><li>Tanuló elem: A kritikustól kapott, az ágens működéséről szóló visszajelzést használja annak megállapítására, hogy a végrehajtó elemet hogyan kell módosítani annak érdekében, hogy a jövőben jobban működjön az ágens. - 	Problémagenerátor: A feladata, hogy olyan cselekvéseket javasoljon, amelyek új és informatív tapasztalatokhoz vezetnek. </li></ul><p> </p><h2>Problémamegoldó ágensek </h2><ul><li>Célorientált ágensek egyik típusa </li><li>Olyan cselekvés sorozatokat keresnek, amelyek a kívánt állapotokba vezetnek </li><li>Célmegfogalmazás: Problémamegoldás első lépése. Pillanatnyi helyzeten és az ágens hasznosságmértékén alapul. Korlátozza az ágens által elérendő dolgok számát, a döntési probléma nagy mértékben leegyszerűsödik. </li><li>Problémamegfogalmazás: Az a folyamat, amely során eldöntjük, hogy mely cselekvéseket és állapotokat vegyünk figyelembe, ha egy cél adott. </li><li>Keresés: Lehetséges cselekvés sorozatok előállításának a folyamata. Bemenete egy probléma. Kimenete egy cselekvés sorozat formájában előálló megoldás. Kiinduló állapotból a célállapotba vezet. A megoldásban szereplő cselekvés sorozat végrehajtása a végrehajtási fázis. </li></ul><p> </p><p>Összességében: </p><ul><li>Először a célt és a problémát fogalmazza meg </li><li>Megkeresi a problémát megoldó cselekvés sorozatot </li><li>Végül a cselekvéseket egyenként végrehajtja </li><li>Amikor kész vele, egy másik célt fogalmaz meg és az egészet újrakezdi </li></ul><p> </p><h2>Ágens környezetének jellemzői </h2><ul><li>Statikus: Környezet változásáról nem vesz tudomást. </li><li>Megfigyelhető: Kezdeti állapot megállapítása könnyebb. </li><li>Diszkrét: Problémamegfogalmazásánál megadott cselekvések lehetnek. </li><li>Determinisztikus: A megoldások egyedi cselekvés sorozatok, váratlan eseményeket nem tudják figyelembe venni. </li></ul><p> </p><h2>Probléma megfogalmazása </h2><p>4 komponens szükséges: </p><ul><li>Kiinduló állapot: Ebből kezdi az ágens a cselekvéseit </li><li>Lehetséges cselekvések halmaza: Általában az állapotátmenet-függvényt alkalmazza. A függvény </li></ul><p>egy adott X állapot esetén visszaadja a rendezett cselekvés-utódállapot párok halmazát, ahol minden cselekvés az X állapotban legális cselekvések egyike és minden utódállapot egy cselekvésnek az X állapotra való alkalmazásával nyerünk. Az állapottér a kezdeti állapot és az állapotátmenet-függvény együttesen implicit módon definiálják azon állapotok halmazát, amelyek a kiinduló állapotból elérhetőek. Az állapottér egy útja az állapotok egy sorozata, amely az állapotokat a cselekvések egy sorozata köt össze.  </p><ul><li>Célteszt: Meghatározza, hogy egy adott állapot célállapot-e. Néha létezik a lehetséges célállapotok egy explicit halmaza, és a teszt egyszerűen megnézi, hogy az ágens elérte-e ezek egyikét. </li><li>Útköltség függvény: Minden úthoz hozzárendel egy költséget. Az ágens azt a költségfüggvényt fogja választani, amely a saját hatékonysági mértékének felel meg. A megoldás kvalitását az útköltség függvény méri, és egy optimális megoldásnak a megoldások közt a legkisebb lesz az útköltsége. </li></ul><p> </p><h2>Keresési fa </h2><p>Egy csomópontot öt komponensből álló adatszerkezettel reprezentálhatunk: </p><ul><li>Állapot: Az állapottérnek a csomóponthoz tartozó állapota </li><li>Szülő-csomópont: A keresési fa azon csomópontja, amely a kérdéses csomópontot generálta. </li><li>Cselekvés: A csomópont szülő-csomópontjára alkalmazott cselekvés. </li><li>Út-költség: A kezdeti állapotból a kérdéses csomópontig vezető út általában g(n)-el jelölt költsége, ahogy ezt a szülőmutatók jelzik. </li><li>Mélység: A kezdeti állapotból vezető út lépéseinek a száma. Perem: Lista, amely a legenerált, </li></ul><p>kifejtésre váró csomópontokat nyilvántartja. </p><p> </p><h2>Algoritmus hatékonyságának mérése </h2><ul><li>Teljesség: Az algoritmus garantáltan megtalál egy megoldást, amennyiben létezik megoldás. </li><li>Optimalitás: A stratégia megtalálja az optimális megoldást. </li><li>Időigény: Mennyi ideig tart egy megoldás megtalálása. </li><li>Tárigény: A keresés elvégzéséhez mennyi memória szükséges. </li></ul><p> </p><h1>Keresési algoritmusok csoportosítása </h1><p>- 	Nem informált keresés: Semmilyen információjuk nincs az állapotokról a probléma definíciójában megadott információn kívül. Működésük során mást nem tehetnek, mint a következő állapotok generálása és a célállapot megkülönböztetése a nem célállapottól. </p><p> </p><ul><li>Szélességi keresés: A fában igyekszik először a gyökérhez közelebbi csúcsokat átvizsgálni, és csak azután folytatja a keresést a mélyebb csúcsokon. Megvalósítás olyan üres peremmel történik, amely egy először-be-először-ki (FIFO) sor, biztosítva ezzel, hogy a korábban meglátogatott csomópontokat az algoritmus korábban fejti ki.  </li></ul><p> </p><p>Tulajdonságai: </p><ul><li><ul><li>Teljes: Ha a legsekélyebb célcsomópont valamilyen véges d mélységben fekszik, a szélességi keresés eljut hozzá az összes nála sekélyebben fekvő csomópontot kifejtve. </li><li>Nem feltétlenül optimális: Optimális, ha az útköltség a csomópont mélységének nem csökkenő függvénye. Pl.: Ha minden cselekvésnek ugyanannyi a költsége ▪ Magas tárigény: Legyen b az elágazási tényező, a megoldás d mélységben található, akkor az összes csomópont száma: b + b<sup>2</sup> + b<sup>3</sup> + … + b<sup>d </sup>+ (b<sup>d+1</sup>-b) = O(b<sup>d+1</sup>) ▪ Minden legenerált csomópontot a memóriában el kell tárolni, mert vagy a perem eleme, vagy egy perem béli csomópont őse. </li></ul></li><li>Egyenletes költségű keresés </li><li>A szélességi keresés optimális, ha minden lépés költsége azonos </li><li>Egyenletes költségű keresés tetszőleges lépésköltség mellett optimális </li><li>Mindig a legkisebb útköltségű n csomópontot fejti ki először, nem pedig a legkisebb </li></ul><p>mélységű csomópontot. </p><ul><li>Mindig végtelen hurokba kerül, ha egy csomópont kifejtése zérus költségű cselekvéshez és ugyanahhoz az állapothoz való visszatérést eredményez </li><li>Optimalitás elégséges feltétele: Minden lépés költsége egy kis pozitív e konstansnál nagyobb, vagy azzal egyenlő </li><li>Idő és tárkomplexitás: O(b<sup>1+[C*/E]</sup>) </li><li>Ha minden lépés egyenlő költségű, akkor O(b<sup>d+1</sup>) idő és tárkomplexitású o Mélységi keresés </li><li>A keresés azonnal a fa legmélyebb szintjére jut el, ahol a csomópontoknak már nincsenek követőik. Kifejtésüket követően kikerülnek a peremből és a keresés visszalép ahhoz a következő legmélyebben fekvő csomóponthoz, amelynek vannak még ki nem fejtett követői. </li></ul><p> </p><p>Tulajdonságai: </p><ul><li>Nem teljes: Ha a bal oldali részfa korlátlanul mély lenne és nem tartalmazna megoldást, a mélységi keresés soha nem állna meg. </li><li>Nem optimális: Egy rossz választással egy hosszú út mentén lefelé elakadhat, miközben pl. egy más döntés elvezetne a gyökérhez közeli megoldáshoz. </li><li>Alacsony tárigény: Csak egyetlen, a gyökércsomóponttól egy levélcsomópontig vezető utat kell tárolnia, kiegészítve az út minden egyes csomópontja melletti kifejtetlen csomópontokkal. Egy kifejtett csomópont el is hagyható a memóriából, feltéve, hogy az összes leszármazottja meg lett vizsgálva. </li><li>Tárigény: b*m+1, ahol a b az elágazási tényező, m a maximális mélység az állapottérben. A mélységi keresés visszalépéses keresésnek nevezett változata még kevesebb memóriát használ. A visszalépéses keresés az összes követő helyett egyidejűleg csak egy követőt generál. Minden részben kifejtett csomópont emlékszik, melyik követője jön a legközelebb. Ily módon csak O(m) memóriára van szükség. </li><li>Mélységkorlátozott keresés <ul><li>Végtelen fák problémájának kiküszöbölésére való </li><li>Az utak maximális mélységére egy l korlátot ad. Az l mélységben lévő csomópontokat úgy kezeli, mintha nem is lennének követőik.  </li></ul></li></ul><p> </p><p>Tulajdonságai: </p><ul><li><ul><li>Nem teljes: Ha l &lt; d-t választunk, azaz, ha a legsekélyebb célcsomópont a mélységkorláton túl van. </li><li>Nem optimális: A mélységkorlátozott keresés l &gt; d választással sem lesz optimális. </li></ul></li><li>Iteratívan mélyülő mélységi keresés <ul><li><ul><li>Fokozatosan növeli a mélységkorlátot. Legyen először 0, majd 1, majd 2 stb. amíg a célt meg nem találja. Ez akkor következik be, ha a mélységkorlát eléri a d-t, a legsekélyebben fekvő célcsomópont mélységét.  </li><li>Iteratívan mélyülő keresésben a legmélyebb szinten (d mélység) található csomópontokat csak egyszer fejtjük ki, egy szinttel feljebb kétszer stb. egészen a gyökér gyerekeiig, amelyeket d-szer fejtünk ki. </li></ul></li></ul></li></ul><p> </p><p>Tulajdonságai: Szélességi és a mélységi keresés előnyös tulajdonságait ötvözi. </p><ul><li><ul><li><ul><li>Teljes </li><li>Optimális, ha minden cselekvésnek azonos a költsége </li><li>Alacsony tárigény: O(b<sup>d</sup>) o Kétirányú keresés </li><li>Egyszerre el lehet indítani egy keresést előrefelé a kiinduló állapotból és hátrafelé a célállapotból, a keresés akkor fejeződik be, ha a két keresés valahol találkozik. </li><li>A kétirányú keresést úgy implementálják, hogy az egyik vagy mindkét keresés egy csomópont kifejtése előtt megvizsgálja, hogy az nem része-e a másik keresési fa peremének. Ha igen, megvan a cél. </li><li>Ha a probléma pl. d = 8 megoldás mélységű, a két keresés a legrosszabb esetben akkor találkozik, ha mindegyik algoritmus 4-es mélységben egy csomópont kivételével minden csomópontot kifejtett. </li><li>Idő és tárkomplexitása: O(b<sup>d/2</sup>) </li></ul></li></ul></li></ul><p>	- 	Informált vagy heurisztikus keresés: Tudják, hogy az egyik közbülső állapot ígéretesebb, mint egy </p><p>másik közbülső állapot. Problémaspecifikus információkat is figyelembe veszünk. </p><p> </p><ul><li>Legjobbat-először keresés <ul><li><ul><li><ul><li>Az általános fa-keresés vagy gráf-keresés algoritmusok olyan speciális esete, ahol egy csomópont kifejtésre való kiválasztása egy f(n) kiértékelő függvénytől függ. </li><li>Egy prioritási sor segítségével implementálható, ami egy olyan adatstruktúra, amely a peremet növekvő f-értékek szerint rendezi. </li><li>Egy keresési algoritmus család, amelynek az elemeit az eltérő kiértékelő függvények különböztetik meg. </li></ul></li></ul></li></ul></li><li>Mohó legjobbat-először keresés <ul><li><ul><li><ul><li>Azt a csomópontot fejti ki a következő lépésben, amelyiknek az állapotát a legközelebbinek ítéli a célállapothoz, abból kiindulva, hogy így gyorsan megtalálja a megoldást. </li></ul></li></ul></li></ul></li></ul><p> </p><p>Tulajdonságai: </p><ul><li><ul><li><ul><li><ul><li>Nem teljes: Elindulhat egy végtelen úton és sohasem tér vissza újabb lehetőségeket kipróbálni </li><li>Nem optimális </li><li>Worst-case idő és tár igény: O(b<sup>m</sup>), ahol m a keresési tér maximális mélysége o A* keresés </li><li>Legjobbat-először keresés leginkább ismert változata </li><li>A csomópontokat úgy értékeli ki, hogy összekombinálja g(n) értékét az aktuális csomópontig megtett út költsége, és h(n) értékét, vagyis az adott csomóponttól a célhoz vezető út költségének becslőjét: f(n) = g(n) + h(n) </li><li>f(n) a legolcsóbb, az n csomóponton keresztül vezető megoldás becsült költsége </li><li>A fa-keresés optimális, ha h(n) elfogadható heurisztika soha nem becsüli felül a cél eléréséhez szükséges költséget </li></ul></li></ul></li></ul></li><li>Memóriakorlátozott heurisztikus keresés <ul><li><ul><li><ul><li>A* algoritmus worst-case idő és tárkomplexitás: O(b<sup>d</sup>) – exponenciális ▪ Az A* memóriaigényének mérséklésére a legegyszerűbb módszer az iteratívan mélyülő algoritmus (IMA*) adaptálása heurisztikus keresés környezetre.  </li><li>Az IMA* és a közönséges iteratívan mélyülő algoritmus közötti fő különbség az, hogy a vágási mechanizmus nem a mélységen, hanem az f költségen (g+h) alapul. Ezáltal minden egyes iterációban a vágási érték az a legkisebb f költség, ami az előbbi iterációban használt vágási értéknél nagyobb. </li><li>Az IMA* praktikus megoldás számos olyan probléma esetén, ahol egységnyi a lépésköltség </li><li>IMA* worst-case tárkomplexitás: A megoldás mélységével lineáris </li><li>IMA* teljes és optimális keresés o Rekurzív legjobbat-először keresés </li><li>A struktúrája hasonlít a rekurzív mélységi keresésre, azonban ahelyett, hogy az algoritmus egy utat a végtelenségig folytatna az aktuális pálya mentén, figyeli az aktuális csomóponthoz az elődjeitől vezető eddigi alternatív út f-értékét. Ha az aktuális csomópont ezt az értéket túlhaladja, a rekurzió az alternatív útra lép vissza. Ahogy a rekurzió visszalép, a keresés algoritmus minden csomópont f-értékét a pálya mentén a gyerekeinek legjobb f-értékével helyettesíti. </li><li>Tárkomplexitása: O(b<sup>d</sup>)  </li></ul></li></ul></li></ul></li></ul><p> </p><h2>Lokális keresési algoritmusok </h2><ul><li>Csak egy aktuális állapotot vesznek figyelembe és általában csak ennek az állapotnak a szomszédjaira lépnek tovább. A keresés által követett utat tipikusan nem is tárolják el. </li><li>2 alapvető előnyük van: Igen kevés, általában konstans mennyiségű memóriát használnak. Sokszor nagy vagy végtelen keresési térben elfogadható megoldást produkálnak ott, ahol a szisztematikus algoritmusok alkalmatlanok lennének a nagy tár ls időigényük miatt. </li></ul><p> </p><h2>Állapotfelszín </h2><ul><li>Célfüggvény esetén a cél a globális maximum megtalálása. </li><li>Költségfüggvény esetén a cél a globális minimum megtalálása. </li></ul><p> </p><p><strong>Hegymászó algoritmus </strong>A keresés egyszerűen csak egy ciklus, ami mindig javuló értékek felé, azaz, felfelé lép. Minden lépésben az aktuális csomópontot a legjobb szomszédjával cseréli le. Az algoritmus megáll, amikor felér a csúcsra, ahol nincsenek már magasabb értékű szomszédjai. Nem tart nyilván keresési fát, ezért a csomópontot leíró adatszerkezetnek csak az állapotot és a célfüggvény értékét kell nyilvántartania. Nem néz előre az aktuális állapotot közvetlenül követő szomszédokon túl. </p><p>A hegymászás gyakran megakad olyan problémák miatt mint: </p><ul><li>Lokális maximumok: Egy csúcs, amely minden szomszédjánál magasabb, de a globális maximumnál alacsonyabb </li><li>Hegygerincek: Egy olyan lokális maximum sorozatot eredményez, ahol egy mohó algoritmusnak igen nehéz navigálnia. Maximumok nincsenek közvetlen módon egymással összekapcsolva. Minden egyes lokális maximumból az összes lehetséges cselekvés a lejtőn lefelé mutat. </li><li>Fennsík: Az állapottérnek egy olyan területe, ahol a kiértékelő függvény gyakorlatilag lapos. Lehet ez egy lapos lokális maximum, amelyből nincs tovább felfelé, de lehet egy váll, ahonnan még lehetséges az előrehaladás. Fajtái? </li><li>Sztochasztikus hegymászó keresés: A felfelé mutató irányokból véletlen módon választ </li><li>Elsőnek-választott hegymászó algoritmus: Sztochasztikus hegymászó keresést használ. A követőket véletlen módon addig generálva, amíg az az aktuális állapotnál nem lesz jobb. Jó stratégia lehet, ha egy állapotnak sok követője van. </li><li>Véletlen újraindítású hegymászás: Véletlenül generált kiinduló állapotokból hegymászó keresést </li></ul><p>végez, amíg célba nem ér. Teljes, de nem hatékony. </p><p> </p><h2>Szimulált hűtés </h2><ul><li>Hatékony és teljes algoritmus </li><li>Legjobb lépés megtétele helyett azonban egy véletlen lépést tesz </li><li>Ha a lépés javítja a helyzetet, akkor az mindig végrehajtásra kerül </li><li>Ellenkező esetben az algoritmus a lépést csak valamilyen 1-nél kisebb valószínűséggel teszi meg. A valószínűség exponenciálisan csökken a lépés rosszaságával, azzal a ΔE mennyiséggel, amivel a kiértékelő függvény értéke romlott. A valószínűség a T hőmérséklet csökkenésével is csökken. A rossz lépések az indulásnál T magasabb értékeinél valószínűbbek, T csökkenésével egyre valószínűtlenebbé válnak. </li></ul><p> </p><h2>Lokális nyaláb keresés algoritmus </h2><ul><li>Nem egy, hanem k állapotot követ nyomon </li><li>Az algoritmus k véletlen módon generált állapottól indul. Minden lépésben a k állapot mindegyikének összes követőit kifejti. </li><li>Ha ezek valamelyike egy cél, az algoritmus leáll. Egyébként a teljes listából kiválasztja a legjobb k követőt, és ezt az eljárást ismétli. </li><li>Hátránya, hogy az állapotok gyorsan koncentrálódhatnak a tér egy kicsi részében. Sztochasztikus nyaláb keresés, amikor a k legjobb követő megválasztása helyett az algoritmus a k követőt véletlen módon választja ki, ahol egy adott követő kiválasztásának valószínűsége az állapot értékének növekvő függvénye. </li></ul><p> </p><h2>Online kereső ágensek </h2><p>A számítás és a végrehajtás átlapolódik. Először végrehajtanak egy cselekvést, majd megfigyelik a környezetüket és kiszámítják a következő cselekvést: </p><ul><li>Dinamikus, szemidinamikus környezetekben </li><li>Sztochasztikus környezetekben </li><li>Felfedezési problémák esetén az állapotok és a cselekvések ismeretlenek az ágens számára </li></ul><p> </p><p>Az ágens az alábbiakat tudja: </p><ul><li>Cselekvések, amely az s állapotban engedélyezett cselekvések listáját adja vissza </li><li>Lépésköltség - 	Cél-teszt Az ágens nem képes egy állapot követőit másképpen elérni, mint hogy az adott állapotban az összes cselekvését kipróbálja. Egy online kereső ágens minden cselekvés után érzékeli, hogy milyen állapotba került. Ebből az információból felépítheti környezetének térképét. </li></ul><p>Ágens célja: Elérjen egy célállapotot és eközben minimalizálja a költségeket </p><p>Kompetitív arány: Ágens által megtett tényleges út teljes költségének és az aktuális legrövidebb út aránya. </p><h1>Fuzzy </h1><h2>Algoritmusok bonyolultsága </h2><p>A bonyolultság/komplexitás az algoritmusok egyik legfontosabb tulajdonsága. Valójában több komplexitás definiálható, ennek megfelelően több tulajdonság is. Megadja a megoldandó probléma mérete és a megoldásához szükséges erőforrás közötti összefüggés jellegét leíró függvényt. A probléma mérete a megoldandó feladatot leíró jellemző, pl. mátrix dimenzióinak mérete, gráf éleinek száma stb. Az erőforrás lehet időigény, végrehajtandó lépések/utasítások száma, tárigény stb. Uniform bonyolultságú aszimptotikus komplexitás n: A probléma mérete g(n): A függvény </p><p>O(f(n)): A függvény nagyságrendje, ha létezik olyan c, melyre g(n) &lt;= cf(n) minden n &gt;= 0 esetén  </p><h2>Algoritmusok bonyolultságának csökkentési lehetőségei </h2><p>Szabályredukció: Nyelvi változók számának csökkentése, szabályok számának csökkentése, viszont az algoritmus bonyolultsága marad. </p><h1>Metaheurisztikus algoritmusok alapjai </h1><h2>Optimalizálás </h2><p>Cél a több alternatív lehetséges megoldás közül valamilyen szempont, vagy szempontok alapján a legjobb optimális megoldás kiválasztása. </p><p>Keresési tér: Az egy dimenzióból szinte a végtelen dimenzióig terjedhet. Lehet diszkrét és folytonos is. </p><p>Globális optimum: Ha a teljes keresési térre vonatkozó legjobb megoldásról van szó. Lehet belőle több is, jósága teljesen megegyezik, de elhelyezkedésük eltérő. </p><p>Lokális optimum: A keresési tér egy kisebb részére vonatkozó optimum. A megoldás szűk környezetére vonatkozó legjobb megoldás. Természetesen a globális optimum bizonyos szempontból lokális optimum is. Egyes esetekben a keresési tér bonyolultsága miatt nem, vagy nagyon nehezen, sok idő alatt található meg az optimális megoldás. Pl. utazóügynök probléma, ilyen esetekben a garantált optimális megoldást csak az összes megoldás összehasonlítása révén lehet előállítani – egyáltalán nem hatékony. A valós problémák esetében a rendelkezésünkre álló erőforrások korlátosak. Akár számítási teljesítményben, időben. Előfordul, hogy kompromisszumként nem a globális optimumot keressük, hanem egy úgynevezett kvázi optimális megoldást. A kvázi optimum lehet az optimumot adott mértékben megközelítő megoldás vagy az adott idő, számítási lépések alatt elérhető addigi legjobb.  </p><p>Néhány híres NP-nehéz feladat:  </p><ul><li>Hozzárendelési feladat </li><li>Utazó ügynök probléma </li><li>Ládapakolás </li><li>Hátizsák probléma </li><li>Halmazlefedési feladat </li></ul><p> </p><p>A keresés során megkülönböztetünk informált és nem informált keresést. Előbbi esetén az egyes megoldás jelöltekről rendelkezünk valamilyen minőségi leírással. A nem informált keresés esetén csakannyi információval rendelkezünk, hogy a kiválasztott megoldás egyezik-e a keresett céllal. </p><h2>Metaheurisztikus módszerek </h2><ul><li>Determinisztikus algoritmusok o Konvencionális optimalizáló algoritmusok, pl. hegymászó algoritmus, lineáris és nem lineáris programozás <ul><li>Két vagy több lefutás során azonos bemenetet feltételezve mindig ugyanazt az eredményt hozzák, a lépések nem térnek el </li></ul></li><li>Sztochasztikus algoritmusok o Működésében nagy szerepet játszanak a véletlen számok <ul><li>Heurisztikus: Nem garantálják, hogy megtalálják az optimumot. A probléma valamilyen előzetes ismerete alapján felállított stratégia mentén kutatja át azt. Kvázi optimális megoldást gyakran nagyságrendekkel gyorsabban talál meg a determinisztikus megoldásokhoz képest. o Metaheurisztikus: Nincs egységben meghatározva. Felsőbb heurisztikát jelent. Iteratív folyamatok irányítására szolgáló stratégiák, melyek célja optimum megoldásokat találni a keresési tér hatékony felderítése révén. </li></ul></li></ul><p> </p><h2>Metaheurisztikus keresőalgoritmusok tesztelése </h2><p>Benchmark függvények csoportosításának főbb szempontjai: </p><ul><li>Modalitás: A félrevezető csúcsok száma utal a függvény modalitására, aminek lényegében a célja, hogy minél több lehetőséget adjon arra, hogy a lokális optimumba ragadjon az algoritmus a viselkedéstől függően. </li><li>Tálak: Egy nagyobb területet körbezáró nagy meredekségű alakra utal, ami nagyon vonzó egyes algoritmusok számára, hiszen egyes heurisztikák a hirtelen javulás irányába indulnak. </li><li>Völgyek: Akkor beszélünk völgyről, ha kisebb változatosságú szűk területet meredek falak vesznek körül, hasonlóan a tálakhoz, ez is különösen vonzó az olyan megoldások számára, amely két megoldás jósága közötti eltérés nagysága alapján dönt a következő lépésről. </li><li>Szeparálhatóság: A különböző benchmark függvények bonyolultságára utal, a szeparálható problémákat jellemzően könnyű megoldani, hiszen minden függvényváltozó független a többi változótól, melynek köszönhetően független optimalizációs folyamatok végezhetőek el, vagyis minden változó külön optimalizálható. </li><li>Dimenziók: Általánosságban elmondható, hogy egy probléma dimenzióinak számával együtt nő annak bonyolultsága is, mivel a paraméterekkel együtt a keresési tér mérete exponenciálisan nő. </li></ul><p> </p><h1>Metaheurisztikus algoritmusok alapjai </h1><h2>Metaheurisztikus optimalizáló algoritmusok csoportosítása </h2><p>Az algoritmusok e családja nagyszámú és tagjai eltérő jellemzőkkel rendelkezhetnek. Számos csoportosítási lehetőség fellelhető, az egyik szerint 5 csoportba sorolhatóak: </p><ul><li>Koncepció o Természet inspirálta módszerek ▪ Bakteriális evolúciós algoritmus <ul><li><ul><li>Az ősrobbanás – nagy reccs algoritmus </li><li>Hangyakolónia algoritmus </li><li>Mesterséges immunrendszer módszer o Nem természet inspirálta módszerek </li><li>Tabu keresés: Minden lépésnél elfogadhatóak a rosszabbodó lépések, ha nem áll rendelkezésre javító lépés. Ezen kívül tiltásokat vezetnek be, hogy megakadályozzák a keresést, hogy visszatérjen a korábban látogatott megoldásokhoz. A megvalósítás memóriastruktúrákat használ, amelyek leírják a felkeresett megoldásokat vagy a felhasználó által megadott szabálykészleteket. Ha egy lehetséges megoldást egy bizonyos rövid távú időszakon belül korábban meglátogattak, vagy szabályt sértett, akkor tabuként jelölik, hogy az algoritmus ezt a lehetőséget ne vegye figyelembe ismételten.  </li><li>Iterált lokális keresés </li></ul></li></ul></li><li>Egyidőben tárolt megoldások o Populáció alapú: Egyszerre több megoldásjelölttel rendelkeznek, ezek a fejlődése során történik a megoldások optimalizálása. Lehetséges több párhuzamos populáció is. <ul><li>Egypontos: Egyetlen megoldással dolgoznak. Trajektória módszerek. Lényegében egy pont fejlődése során egy utat jár be. Pl. tabu keresés, változó szomszéd kereső eljárás  </li></ul></li><li>Célfüggvény időbeni változása o Dinamikus célfüggvényű módszer: Célja az, hogy elkerülje az esetleges lokális optimumokba való ragadást. Pl. irányított lokális keresés <ul><li>Statikus célfüggvényű módszer: Leggyakoribb módszer </li></ul></li><li>Szomszédsági struktúra o Szomszédsági struktúrájú: Amennyiben nem változik a fitnesz topológia a keresés során. <ul><li>Változó szomszédsági struktúrájú: Pl. a változó szomszéd kereső eljárás eltérő szomszédsági struktúrákat alkalmaz. Lehetővé teszi, hogy váltson a különböző fitnesz terepek között. </li></ul></li><li>Memória <ul><li>Memóriát használó: Keresési folyamat lépéseit tárolja. Rövid távú memóriával rendelkező az pl. az előző lépések, bizonyos döntések, addigi megoldásuk közül választ. A hosszú memóriával rendelkező valamilyen akkumulált szintetikus paramétereket használ. </li><li>Memória mentes: Nem tárol visszamenőleges adatokat. </li></ul></li></ul><p> </p><h2>Genetikus algoritmus </h2><p>John Holland mutatta be az 1960-as években. Különösen nagy népszerűségnek örvendett az 1970-es évek elejétől kezdve. Mára szinte megszámlálhatatlan módosított változata létezik. Alapelve a Darwin féle evolúciós elméleten alapul, azon belül is a természetes szelekción. A környezetükhöz legjobban alkalmazkodott egyedek tovább élnek és több utódot hoznak létre.  </p><p>Az egyes megoldásokat úgynevezett kromoszómákban kódolja. Bináris vektorként reprezentálnak, ezeket hívják egyedeknek. Általánosították tetszőleges n elemű vektorra. Állhat karakterekből, egész számokból, valós számokból, ez a természetes genom. A populáció adott számú kromoszómából áll, ezek a különböző megoldásjelöltek, együtt élő élőlényeknek feleltethetőek meg. Az egy időben élő megoldások alkotják a generációt. Az egyes megoldások jóságának leírására a fitnesz függvény szolgál. </p><p>3 alapvető genetikus operátor: </p><ul><li>Szelekció: Kiválasztja a továbbjutó, keresztezésre jelölt egyedeket </li><li>Keresztezés: Két kromoszómából állít elő egy vagy több új kromoszómát. Lényegében két megoldást kombinálva új megoldást alkot. </li><li>Mutáció: Adott valószínűséggel bármelyik egyedben végbe mehet. Véletlenszerűen módosítja a </li></ul><p>kromoszóma egy részét. </p><p> </p><p>Egyes operátorokra több alternatív módszer is létezik. </p><h2>Szelekcióról részletesen </h2><p>Fitnesz arányos kiválasztás, másnéven rulettkerék módszer. A kromoszómák a jóságukkal arányos méretű szeletet kapnak a rulettkerékből. A kis jóságú kromoszómák is kiválasztásra kerülhetnek, csak kisebb valószínűséggel. A jobb egyedek nagyobb valószínűséggel kerülnek kiválasztásra. </p><p>További módszerek: random szelekció, levágó szelekció, verseny szelekció, jutalom alapú szelekció, sztochasztikus univerzális szelekció </p><h2>Keresztezésről részletesen </h2><p>Számos alternatív megoldás létezik. Nagyban függ a kódolástól, hogy milyen a kromoszómákat leíró adatszerkezet és az arra vonatkozó megkötések. </p><p>Tipikus megoldások a vektor jellegű kromoszómák esetén: </p><ul><li>Egypontos keresztezés: A két szülő kromoszómát egy véletlenszerűen kiválasztott pontban levágjuk és a levágott részeket felcserélve megkapjuk az utódokat. </li><li>Többpontos keresztezés: A két szülő kromoszómát több véletlenszerűen kiválasztott pontban elvágjuk és a levágott részeket felcserélve megkapjuk az utódokat. </li><li>Uniform keresztezés: A két szülő kromoszómát minden második pontban felcserélve megkapjuk az utódokat. </li><li>Aritmetikai keresztezés: A két szülő kromoszómát egy tetszőleges f függvény segítségével </li></ul><p>kombináljuk. </p><p> </p><h2>Mutációról részletesen </h2><p>Kromoszómák véletlenszerű megváltoztatása. Több változata is van, az eredeti változatban a populáció elemeit adott valószínűséggel kiválasztjuk és egy véletlenszerűen kiválasztott gént módosítunk.  </p><h2>Visszahelyettesítés </h2><p>Populáció mérete jellemzően fix, de a keresztezés és a mutáció során új egyedeket is létrehoztunk. Melyik egyedeket tartsuk meg a populációban a következő generációban?  </p><p>Két nagy csoport: - 	Fitnesz alapú módszerek: </p><ul><li>Generációs modell: Ugyanannyi egyedet hozunk létre a keresztezés és a mutáció során összesen amennyi a populáció mérete. Az újonnan létrehozott egyedek fogják a populációt alkotni. </li><li>λ &lt; μ: Legrégebbi stratégia </li><li>Legrosszabb egyedek helyettesítése: μ egyedszámú populáció legrosszabb λ egyedét </li></ul><p>helyettesítjük a létrehozott λ utóddal. </p><ul><li>(μ + λ) kiválasztás: μ elemú populáció és λ utód együttes rangsorolása, majd legjobb μ db egyed kiválasztása </li><li>(μ, λ) kiválasztás: tipikusan λ &gt; μ több utódot hozunk létre, mint a populáció mérete. λ db utód rangsorolása, és a μ db legjobb fogja a populációt alkotni. </li></ul><p>	- 	Életkor alapú módszerek </p><p> </p><h2>Bakteriális Evolúciós algoritmus </h2><p>Közvetlen elődje az 1997-ben bemutatott pszeudo-bakteriális genetikus algoritmus. Ezt fuzzy logikai vezérlők generálására alkották meg. A genetikus algoritmusokhoz képest annyiban volt új a módszer, hogy bakteriális mutációt használt. </p><p>A bakteriális evolúciós algoritmust 1999-ben N. E. Nawa és T. Furuhashi publikálták. Céljuk a fuzzy rendszerek optimális paramétereinek keresése volt. A baktériumok fejlődésének koncepcióját alkalmazták. A bakteriális mutáción felül génátadás, vagy más néven a géntranszfer operátort alkalmazza. A baktériumok vagy egyedek a kódolt megoldás jelöltek az adott problémára. Az egyedek valamely tulajdonságait az úgynevezett gének tárolják, azok értékei az allélok. Az egyes baktériumok jóságának, vagy alkalmassági mértékének meghatározására nincs szükség külön fitnesz függvényre. Az adott probléma kiértékelése használatos erre a célra. Az egyedek összessége alkotja a baktérium populációt. Az azonos időben létező egyedek képezik az egyes generációkat. </p><ul><li>Bakteriális mutáció: A populáció minden egyedén külön-külön végrehajtott operátor. A baktérium jóságának önálló, más egyedtől származó információátadás nélküli javítása a cél. A módszer garantálja, hogy az eredeti baktérium jósága nem romolhat.  </li></ul><p> </p><p>Lépései egy kiválasztott baktériumra vonatkozóan: </p><ul><li><ul><li><ul><li>A kiválasztott baktériumot nk számban klónozzuk o Egy véletlenszerűen kiválasztott allélt véletlenszerűen megváltoztatunk az összes klónban o Kiértékeljük a módosított klónokat és kiválasztjuk a legjobb egyedet a klónok és az eredeti baktérium közül </li><li>A legjobb egyed átadja a korábbi lépésben kiválasztott allélját minden másik egyednek o Ezt a lépéssorozatot addig ismételjük, amíg minden allél kiválasztásra nem került o A lépések végén a módosított baktériumot visszahelyezzük a populációba </li></ul></li></ul></li></ul><p> </p><ul><li>Génátadás: Célja, hogy a populáció egyedei közötti információcserével javítsa a baktériumok jóságát.  </li></ul><p> </p><p>A lépéseit ni alkalommal ismételjük meg: </p><ul><li><ul><li>A populációban található baktériumokat jóság szerint sorba rendezzük </li><li>Egy előre definiált nc pontban elvágjuk a populációt, ezzel a jó és a rossz baktériumok csoportjára osztjuk azt. </li><li>A jó és a rossz baktériumok csoportjából véletlenszerűen kiválasztunk egy-egy egyedet o A kiválasztott jó baktérium átadja egy véletlenszerű allélját a kiválasztott rossz baktériumnak. Amennyiben rögzített hosszúságúak a baktériumok, akkor a rossz baktérium felülírja az allélt, eltérő hosszúságúak, hozzá is fűzheti az allélt </li></ul></li></ul><p> </p><h2>Részecskesereg optimalizáció </h2><p>Particle Swarm Optimization. R. Eberhart és J. Kennedy publikálták 1995-ben. Céljuk a nem lineáris függvények optimalizációja volt. Két paradigmát is javasoltak, illetve vizsgáltak. Az egyik globálisan, a másik lokálisan orientált részecskesereg módszer. </p><p>Az algoritmus a részecskék mozgásának az analógiáját alkalmazza. A füst gomolygásához hasonló az egyes egyedek mozgása. Pl. hasonlít a madarak és a halak összehangolt mozgására. A részecskék a megoldás jelölteket jelképezik, amelyek a keresési térben mozognak. </p><h2>Ősrobbanás – nagy reccs </h2><p>Big Bang – Big Crunch. O. K. Erol és I. Eksin publikálták 2005-ben. Céljuk egy általuk fejlesztett újszerű optimalizációs módszer bemutatása volt. Lényege az univerzum fejlődési analógiájára épül.  </p><p>Ősrobbanás: Egyetlen pontból tágulással jött létre az ismert univerzum. </p><p>Nagy reccs: Ahol az univerzum egyetlen pontba roskad. </p><p>Az univerzum maga a keresési tér. Az univerzum pontjai az egyes egyedek, vagyis a megoldás jelöltek.A jóság kiszámítása valamilyen előre megadott fitnesz függvény alapján történik. Az univerzum keletkezésének analógiájára ez jelképezi a világegyetemben található égitestek tömegét. A benchmark jellegű tesztben összehasonlították algoritmusukat egy genetikus algoritmussal. Az eredmények alapján az új módszer több esetben felülmúlta a genetikus algoritmus által hozott eredményeket. </p><h2>Imperialista Kompetitív algoritmus </h2><p>Imperialist Competitive Algorithm. E. Atashpaz-Gargari és C. Lucas publikálta 2007-ben. Céljuk, egy a birodalmak versengésének mintájára épített optimalizációs algoritmus létrehozása volt. Az egyes országok jelképezik a probléma egy-egy megoldását a keresési térben, vagyis az egyedeket. </p><p>Két csoportba oszthatók: </p><ul><li>Birodalmak (ezek az erősebbek) </li><li>Gyarmatok (ezek a gyengébbek): Különböző birodalmak között szétosztásra kerülnek. </li></ul><p> </p><p>Az országok erősségének meghatározására a költség függvény szolgál. A fitnesz függvényhez hasonló, de működése eltérő. Ha alacsony a költségfüggvény, az azt jelenti erős az ország. Nem csak az egyedek önálló költségfüggvényét határozza meg, a birodalmak és gyarmataik együttes költségfüggvényét is felhasználja. A gyarmatok közelítenek a felettük álló birodalmakhoz. A mozgás következtében azok költségfüggvény-értéke változhat és jobb lehet a hozzájuk tartozó birodaloménál. Egyes gyarmatok erősebbé válhatnak, mint a föléjük rendelt birodalom. Az ilyen esetekben az adott gyarmat átveszi a hatalmat. A versengés során a gyengébb birodalmak elveszíthetik a gyengébb gyarmataikat és azok az erősebb birodalomhoz kerülhetnek. Az erőtlen birodalmak össze is omolhatnak, eltűnnek és gyarmataik szétosztásra kerülnek. </p><p> </p><h1>Mesterséges neurális hálók alapjai </h1><h2>Biológiai neurális hálók </h2><p>Az állatokban és emberekben is megtalálható ideghálózat. A fejlettebb állatok idegrendszerei nagyon összetettek, jellemzően két fő részre osztják: </p><ul><li>Központi idegrendszer: Része az agy és a gerincvelő </li><li>Környéki idegrendszer: Pl. szomatikus és az autonóm idegrendszer </li></ul><p> </p><p>Az idegszövetet két fő sejtcsoport alkotja:  </p><ul><li>Idegsejtek vagyis neuronok: Ingerület kezelésére szolgál </li><li>Gliasejtek: Főként a támasztásért és az agy takarítási funkciójáért felel </li></ul><p> </p><p>Az összetett, intelligens viselkedési minták létrehozásában a neurális hálózatnak van szerepe, amelyet az idegsejtek szinapszisokon keresztüli kommunikációja valósít meg. </p><h2>Biológiai neuron </h2><p>A neuronok tipikus felépítése: - 	Sejttest: Ebben található a sejtmag. A sejttestből ágaznak ki a dendritek, amelyek az ingerületek felvételét teszik lehetővé, illetve az axonok, amiken keresztül továbbításra kerül a dendritek által felvett információ. Az axonokat jellemzően egy zsírbn gazdag, myelinhüvely védi. </p><ul><li>Az idegrendszer alapegységének tekinthetők </li><li>Az információ áramlásáért és feldolgozásáért felelősek </li></ul><p> </p><p>Megjegyzés: Az emberi tudat és intelligencia az agyat alkotó megközelítőleg 90 milliárd neuron és az e neuronok közötti kapcsolatok révén áll elő. Nagyon sokáig úgy tartották, hogy a neuronok az egyetlen olyan sejtek, melyekből nem keletkezik új idősebb korban. A legújabb megfigyelések felnőttek esetén is alátámasztották új idegsejtek létrejöttét. </p><h2>Biológiai neuronok főbb típusai </h2><p>Az idegrendszer különböző területein megtalálható, eltérő célú neuronok nagyon változatos jellemzőkkel bírnak, mind megjelenésben, mind biokémiai tulajdonságait tekintve.  </p><p>Struktúra szempontjából: </p><ul><li>Unipoláris neuronok: Egyszerűbb állatokban, rovarokban a leggyakoribbak. </li><li>Pszeudounipoláris neuronok: Szenzoros neuronok, melyek fizikai és kémiai jelek érzékelésére szolgálnak. Jellemzően ketté ágazó axonnal rendelkeznek. </li><li>Bipoláris neuronok: Pszeudounipoláris neuronokhoz hasonlóan jellemzően a szaglás és látás érzékelésében játszanak szerepet. </li><li>Multipoláris neuronok: Egy axonnal és számos dendrittel rendelkeznek. </li></ul><p> </p><h2>Szinapszis </h2><p>A neuronok szinapszisok révén alakítanak ki kapcsolatokat egymás között. Lehetnek elektromos átvitelűek, a sejtmembránok közötti ioncsatornák révén, vagy kémiaiak az akciópotenciál hatására kibocsátott neurontranszmitterek révén. Ezek főként az idegrendszerben termelődő ingerület átvívő anyagok. Pl. dopamin, szerotonin, adrenalin és a dendriteken található különböző receptorokkal továbbítják az információt. </p><h2>Threshold Logic Unit – TLU </h2><p>Az első biológiai neuronok működését modellező egység. Küszöbérték-logikai egység. McCulloch és Pitts alkották meg. Durva modellje a neuronoknak. Számos lényegi jellemzőt nem vesz figyelembe, azonban szerénysége ellenére viszonylag erős kifejezőerővel bír. Alapvetően bemenetekből, kimenetekből és feldolgozóegységből áll. </p><p>Bemenetén a többi neurontól származó értékek találhatóak, amely lényegében a szinapszist reprezentálja. Amennyiben több neuront kapcsolunk össze, akkor e kapcsolatok erősségét súlytényezőkkel szokás reprezentálni. </p><p>A feldolgozóegység határozza meg a mesterséges neuron kimenetét a bemenetek függvényében. Az eredeti modellben egy egyszerű küszöbfüggvényt alkalmaztak. Ha a bemenetek összege eléri a küszöb szintjét, akkor a kimeneten 1-es jelenik meg, ellenkező esetben 0 az eredmény. A gyakorlatban azonban neuron kimenetének kiszámításához a szignumfüggvényt szokás alkalmazni, vagyis megnézzük, hogy nemnegatív-e a bemenetek összegének és a küszöbértéknek a különbsége. </p><h2>Topológiák </h2><p>Önmagában egy nagyon primitív műveletet végző egység. Az ily módon működő neuronokat különböző konfigurációk szerint lehet egymáshoz kapcsolni. Együttesen már komplexebb problémák leírására is alkalmassá teszi. A hálózatba kötött TLU-k képesek lineárisan szeparálható problémák megoldására. Lineárisan szeparálhatónak tekintjük az Euklideszi térben lévő pontok két halmazát, ha létezik legalább egy olyan pont, egyenes, sík, vagy hipersík, amelynek egyik oldalán az egyik halmaz elemei, míg a másik oldalán a másik halmaz elemei találhatóak. </p><p>Topológia szerint 4 fő csoportba oszthatóak a neurális hálók: </p><ul><li>Egyrétegű, előre csatolt </li><li>Egyrétegű, visszacsatolt </li><li>Többrétegű, előre csatolt </li><li>Többrétegű, visszacsatolt </li></ul><p> </p><p>A mesterséges neurális hálózatok esetén az azonos szinten lévő neuronokat ún. rétegekbe rendezik. Amennyiben a hálózatnak egyetlen bemeneti és egyetlen kimeneti rétege van, akkor egyrétegű hálózatról beszélünk. Többrétegű hálók esetében a bemeneti és a kimeneti rétegek közötti összes többi réteget rejtett rétegeknek hívjuk, amelyekből több is lehet a hálózatban. Rétegenként a neuronok száma eltérő lehet. Az előre csatolt hálózatok esetén a bemeneti réteg felől szigorúan csak a kimeneti réteg irányába halad az információ, míg visszacsatolt hálózatoknál az egyes neuronok kimenete az azonos, vagy korábbi rétegek bemenetére is rá lehet kötve, vagyis az információ visszacsatolásra kerül. </p><p>Sekély, vagyis shallow hálónak nevezik a maximum egyetlen rejtett réteggel rendelkező modelleket. A modern népszerű megoldások esetén az úgynevezett mély neurális hálók a modell architektúrájára utalnak. A mély megoldások jellemzően jóval több rejtett réteggel rendelkeznek. Természetesen ugyanannyi neuron felhasználásával készíthető sekély és mély hálózati topológia is. A vizsgálatok kimutatták, hogy a több réteggel rendelkező megoldások komplexebb modellek megalkotására is képesek. Természetesen a fentiektől eltérő, más jellegű hálózati topológiák is megfigyelhetőek a területen, mint pl. az Elman, Jordan, vagy a versengő hálók. A topológia nagyban meghatározza a neurális háló által modellezhető problémák körét. </p><h1>Tanulás </h1><p>A mesterséges neurális hálók valóban könnyen implementálható, egyszerű alkotóelemekből felépülő, nagyon hatékony modell megalkotására képesek. A mesterséges neuronok változatos működése, összekapcsolásaik elrendezése, valamint a rendszer paraméterei egyaránt hatással vannak a hálózat által reprezentált modellre. Ezeknek a jellemzőknek az ideális meghatározása azonban egy nagyon bonyolult folyamat.  </p><p><strong>A neurális hálóknál is alkalmazott gépi tanulás technikák alapvetően 3 fő kategóriába sorolhatók: </strong></p><ul><li>Felügyelt tanulás: Összetartozó be és kimeneti értékek, úgynevezett tanítópárok állnak rendelkezésre. A paraméterek hangolásának az a célja, hogy a számított válaszok a kívánt válaszokkal minél jobban megegyezzenek, a hálózat kimenete és a kívánt kimenet közötti különbség csökkenjen. </li><li>Nem felügyelt tanulás: A példákhoz nincs külső segítség, azaz, nem adottak az osztálycímkék. Az adathalmazt a modell önállóan dolgozzon fel olyan minták és információk felfedezésére, amelyeket korábban nem fedeztek fel. </li></ul><p>Leggyakoribb feladatok: minták közötti hasonlóság megállapítása, minták csoportosítása, van-e korreláció az adatok között </p><ul><li>Megerősítéses tanulás: A tanítókészlet bemeneti mintázatokból áll, a tanítási ciklus befejezése után egy megerősítéses érték jelzi, hogy az eredmény helyes volt-e vagy sem. Ez alapján történik a súlytényezők tanítása. Egy lehetséges tanítás, hogy a helyes válaszokra kapott bemeneteket és a neuronháló kimenetén kapott eredményt hozzáadjuk a tanító halmazhoz. A rossz válaszok nem kerülnek be a tanítóhalmazba. </li></ul><p> </p><p><strong>Tanulás alapján 2 fő csoportba sorolhatóak a tanuló algoritmusok: </strong></p><ul><li>Struktúra </li><li>Paraméter tanulás </li></ul><p> </p><p><strong>Tanulás lefolyása alapján lehet:  </strong></p><ul><li>Online: A súlyok módosítását minden tanítópont, és a kapott output összehasonlításával elvégezzük. </li><li>Offline: Kiszámoljuk a hibát minden be és kimeneti tanítópárra, de a súlymódosítást csak egyetlen </li></ul><p>egyszer végezzük el egy tanítási cikluson belül. </p><p> </p><h2>Perceptron háló </h2><p>1958-ban Rosenblatt dolgozta ki. Tanulni is képes neurális hálózat. Hardverként is kivitelezésre került. Egy előre csatolt, egyrétegű, TLU-kból álló hálózat.  </p><p>A rétegek számával sokkal komplexebb műveletek végrehajtására is képessé váltak a perceptronok, így nagy népszerűségnek örvendtek. A leírható modellek bonyolultságával új probléma is megjelent: Az ideális paraméterek megtalálása, főként nagy rétegszám esetén. Az akkori hardverek kapacitása nem tette lehetővé, hogy az ilyen mély hálók esetén hatékonyan megtalálják az ideális paramétereket, ami jelentősen visszavette az ilyen típusú megoldások alkalmazását. </p><p>A leggyakoribb alkalmazások a különböző osztályozási feladatok területén figyelhetőek meg. A beszéd és a képfelismerés külön kiemelendő. Bebizonyították, hogy a többrétegű perceptronok univerzális approximátorok. Tetszőleges nem lineáris függvény közelíthető meg elégséges neuronszám esetén, így regresszió analízis segítségével alkothatóak meg a modellek. </p><h2>Többrétegű perceptron háló </h2><p>A be és kimeneti rétegeken túl, legalább egy vagy több rejtett réteggel is rendelkezik. Kezdetben bináris működésűek voltak. Kizárólag lineáris neuronmodellek esetén meghatározható egy ekvivalens be és kimeneti rétegből álló háló. Rájöttek, hogy az aktivációs függvény lecserélésével sokkal komplexebb modelleket is megalkothatnak. Főként a szigmoid átviteli függvényt kezdték el alkalmazni. Ez lett általánosan az előre csatolt neurális háló. </p><h2>Celluláris neurális hálózatok </h2><p>Chua és Yang dolgozta ki 1988-ban. Egyszerű analóg feldolgozóegységek hálózata. Diszkrét rendszereken is megvalósították. Képes a boole-függvények kifejezésére, de akkori elterjedésének oka a masszívan párhuzamos architektúra, ami nagyon gyors jelfeldolgozást tett lehetővé. Gyakran alkalmazták kamerákba ágyazott számítógépeken különböző jelfeldolgozási célokra, másodpercenként több tízezer képkockát képes feldolgozni. </p><p>Minden cella kapcsolatban áll a közvetlen szomszédjával. A legjellemzőbb elrendezés a 2D-s, de más megoldások is fellelhetőek. A cellák csak a szomszédjaikkal vannak kapcsolatban. Minden cella állapotát befolyásolhatják a szomszédok kimeneti és bemeneti értékei. A kölcsönhatások erősségét az A és B mátrixok határozzák meg. A művelet során a cellák párhuzamosan működve és kölcsönhatásban eljutnak egy stabil állapotba, amely valójában az állapotegyenletek megoldása.  </p><p><strong>Önszervező, kohonen hálók </strong>Az elméletét Teuvo Kohonen mutatta be 1981-ben. Sokdimenziós adatok hatékony vizualizálására alkalmas a dimenziók egy hálóba redukálása révén. Csökkenti az adat mennyiségét a hasonlóságok alapján és megőrzi a legfontosabb topológiai információkat és a metrikus kapcsolatokat az elsődleges adatelemek között. Gondolhatunk rá úgyis, mint egy absztrakciós eljárásra. Leggyakrabban 2D-s kimenetű formában találkozhatunk vele, de előfordul egy vagy több dimenziós változat is. </p><p>Az agyban is megfigyelhető jelenségre vezethető vissza. Azonos érzékelésért felelős neuronok egymáshoz nagyon közeli területen helyezkednek el. Azonos vagy nagyon hasonló stimulusra aktiválódó neuronok az adott területen belül is egymáshoz közel helyezkednek el. A bemeneti réteg minden elemét hozzákötjük a háló minden neuronjához. A neuronok itt nem rendelkeznek semmilyen feldolgozási funkcióval. A bemeneti vektor értékei és az egyes neuronok súlytényezői közötti eltérést veszi figyelembe. Az a súlytényező kerül kiválasztásra, amelyik a legkisebb diszkriminancia értékkel rendelkezik, ahol a diszkriminancia függvény leggyakrabban Euklideszi távolság, azonban lehet másféle is, mint pl. koszinusz távolság. <strong>A kohonen háló fontosabb paraméterei </strong></p><ul><li>Bemenetek száma (P) </li><li>Összneuronok - processzáló elemek, csomópontok száma (N) </li><li>Súlymátrix (W – N x P méretű) </li><li>Neuronok topológiai elhelyezkedése (I=1: 1D elhelyezkedés; I=2, 2D elhelyezkedés; I=3, 3D elhelyezkedés) </li><li>V mátrix a csomópontok pozíciójának az eloszlásáról (V – m x I méretű), V mátrix megadja a topológiáját a csomópontoknak </li></ul><p> </p><h2>Kohonen háló topológiák </h2><ul><li>Lineáris rácstopológia </li><li>Gyűrűs rácstopológia </li><li>Négyzetes rácstopológia </li><li>Hexagonális rácstopológia </li><li>Véletlenszerűen generált rácstopológia </li></ul><p> </p><p><strong>Kohonen térkép </strong>Hálóban található csomópontoknak a súlyvektor térben való ábrázolása. A súlyvektor térben minden neuront ábrázolunk egy pontként, ahol a pont koordinátáit az illető neuron súlyai határozzák meg. A szomszédos neuronok egymással össze vannak kötve az alkalmazott rácstopológia szerint. Ha sikeres a tanítás, a Kohonen térképen megjelenített háló kifeszül a rácstopológiának megfelelően. </p><h2>Kohonen hálók tanítása </h2><p>A tanításhoz egy kezdeti súlytényező konfigurációt kell létrehozni. Jellemzően ezres nagyságrendű mintakészletre van szükség. A tanulási ciklus során egyet-egyet véletlenszerűen kiválasztva átadunk a hálónak. Az adott minta vektorhoz legjobban illeszkedő súlyokkal rendelkező csomópontot megkeressük a diszkriminancia függvény segítségével. Úgy módosítjuk a súlyt, hogy az még jobban hasonlítson a mintához. Nem csak a legjobban illeszkedő súlyokkal rendelkező csomópont súlytényezőjét módosítjuk, hanem az azzal szomszédos neuronokét is, szintén úgy, hogy jobban illeszkedjen az aktuális mintához. A végrehajtó módosítás mértéke a legjobban illeszkedő súlyokkal rendelkező csomóponttól való távolsággal fordítottan arányos. </p><h2>Best Matching Unit – BMU győztes neuron meghatározása </h2><p>Általában a minta és az egyes neuronok közötti euklideszi távolság alapján történik. Megtörténik a győztes neuron súlyának a módosítása. Szomszédos neuronok súlyait is módosítjuk. Közeli neuronok súlyait nagyobb, távolabbiakét kisebb mértékben Pl. Gauss függvénnyel módosítjuk. A tanítás során kezdetben a súlytényezőket nagy lépéssel kell tanítani és a szomszédsági függvénnyel a szomszédsági fokot is nagyra kell állítani. Ezáltal lehetővé tesszük a mintáknak egy adott halmazból egy másik halmazba való vándorlását. A tanítás során fokozatosan kell csökkenteni a tanítási együtthatót és a szomszédsági fokot. A tanítási ciklus végén a szomszédsági fokot le kell csökkenteni, hogy csak a győztes neuron súlytényezőit hangoljuk, ellehetetlenítve a mintáknak az osztályok közötti vándorlását. </p><h2>Utazó ügynök probléma megoldása Kohonen-háló segítségével </h2><p>Az utazó ügynök feladatot a következőképpen fogalmazhatjuk meg: adott N város, melyeknek ismerjük a koordinátáit. Elvileg bármelyik városból el lehet jutni az összes többi városba. A feladat az, hogy határozzuk meg a legrövidebb útvonalat, amelyen végig lehet járni a városokat. Minden egyes várost kötelező egyszer meglátogatni, de minden egyes város pontosan egyszer látogatható. </p><p>Lépések: </p><ol><li>Topológia kiválasztása: A megoldás szempontjából az utazó érkezik egy városból és továbbmegy egy célvárosba </li><li>Kohonen-háló bemenete: városok koordinátái </li><li>Miben fogjuk megkapni a megoldást? Minden egyes neuron egy megoldást szolgáltat, és a megoldás, vagyis a meglátogatandó városok koordinátái a neuronháló súlytényezőiben lesznek kódolva a tanítást követően. </li><li>Győztes neuron: Amelyre a pillanatnyi bemenet a legközelebb lesz egy neuron súlytényezőihez, vagyis a legkisebb kimenetet produkáló neuron. </li><li>Neuronok súlyainak módosítása a normalizált Hebb-szabállyal a győztes neuronra, Gauss-</li></ol><p>szomszédsági függvénnyel a közeli neuronokra. </p><p> </p><h2>Színtérkép </h2><p>Bemeneti adatok: színek RGB koordinátái – 15 db szín adatai a tanításhoz Kimenet: 20x30-as Kohonen-térkép </p><p> </p><h2>Felhasználási területek </h2><p>Számos területen alkalmazták a nem felügyelt képessége miatt. Az olyan területeken, mint a klaszterezés, vizualizálás, adatszervezés, jellemzés és felfedezés. </p><h1>Modern neuronmodellek </h1><h2>Modern neuronmodellek általánosságban </h2><p>Napjainkban használt technikák alapjai már évtizedekkel korábbra vezethetőek vissza. 2010-es évek elején megugrott a mesterséges neurális hálózatok bizonyos változatainak és a hozzájuk kapcsolódó módszerek alkalmazása. Ez részben köszönhető a finomított modelleknek és megfizethető olyan számítási kapacitással rendelkező hardver, amely képes már nagyobb modelleket tanítani. A mély neurális hálózatok és azok tanítása a mélytanulási megoldásokkal napjaink legnépszerűbb MI eszközének számítanak. 2018-tól visszaesés figyelhető meg a kutatási eredményekben. Vannak lineáris és nem lineáris egységek. A lineáris egységek bonyolultabb rendszerek esetén nem rendelkeznek kellő kifejezőerővel. A modern megoldások jellemzőbben a nem lineáris aktivációs függvénnyel rendelkező neuronokat használnak. </p><p> </p><h2>ReLU – Rectified Linear Unit </h2><p>Leggyakrabban használt. Negatív értékeknél 0 értéket ad vissza, míg pozitív értékekre lineáris. Egyszerű számításokat végezni vele. Gyorsabb tanulást tesz lehetővé, mint pl. szigmoid aktivációs függvénnyel rendelkező neuronok. </p><h2>ReLU vs. Szigmoid aktivációs függvény </h2><p>A szigmoid és tangens hiperbolikus aktivációs függvények alkalmazása a kevés réteget tartalmazó neuronhálókra szűkül. Az említett függvények gradiense eltűnik mély neuronhálók esetében, </p><p>megakadályozva a neuronháló tanulását. Azaz, hiába adunk újabb rétegeket a hálóhoz, az eredmények nem javulnak. A ReLU aktivációs függvény deriváltja mindig egy és nincs szaturálva a kimenet. Jó megoldást biztosít a mély neuronhálók esetében. A ReLU komoly hátránya, hogy a negatív értékek esetén visszaadott 0 érték csökkenti a rendszer tanulási képességét. Előfordul, hogy a 0 értékek miatt úgy módosulnak a hálózat súlyai, hogy a neuron többé nem aktiválódik, vagyis meghal. <strong>Módosított ReLU koncepciók </strong></p><ul><li>Leaky ReLU: A negatív értékekre vonatkozó módosítás a bemeneti érték 0,01x-esét adja vissza </li><li>Parametrized ReLU: A Leaky ReLU általánosítása. A 0,01 szorzó helyett tetszőleges az ’a’ paraméter érték. </li><li>Randomized ReLU: Amikor a Leaky ReLU által alkalmazott ’a’ paraméter véletlenszerűen veszi fel </li></ul><p>az értékét </p><p> </p><h2>Softplus </h2><p>Gyakran alkalmazott ReLU helyettesítő megoldás. Jellegükben hasonló értéket adnak vissza, mint a ReLUk. Nem szakaszonként lineárisak. </p><h2>Előre csatolt neuron struktúrák </h2><p>A neuronmodelleket nem csak az aktivációs függvény alapján lehet megkülönböztetni, a neurális betöltött funkciója és a bekötésének a módja is fontos. </p><ul><li>Előre csatolt neuron: A legegyszerűbb a szigmoid függvényt alkalmazott általánosított TLU, vagyis egy nem lineáris perceptron. A neuronhoz kötött súlyozott bemeneteken túl egy bias értéket is szoktak használni. Egyszerűen előre csatolt neuronnak is hívják. </li><li>Konvolúciós neuron: Hasonlítanak az egyszerű előre csatolt neuronokhoz. Jellemzően egy adott neuroncsoporthoz van csak csatlakoztatva. Kiválóan alkalmas térbeli információk közvetítésére, különösen képi és hanginformációk feldolgozására. Lényegében az adatot blokkokra bontja. Egy-egy blokkot akár több különálló konvolúciós neuron csoport is használhat, eltérő paraméterezés mellett lényegében eltérő lokális jellemzőket kinyerve. A konvolúciós neuronokat alkalmazó neurális hálókban gyakran alkalmaznak még további neuronokat. A klasszikus értelemben nem neuronok, tágabb értelemben, mint a hálózatba kötött egyszerű feldolgozó egységek, már igen. Tartalmaznak pooling neuronokat, így a reprezentáció méretét csökkentik. Az interpolating neuronok pedig kitöltik a hiányzó köztes értékeket. </li><li>Valószínűségi neuronok: Használnak középértéket, szórást és gyakran együttesen valószínűségi neuronként jelennek meg. Céljuk a valószínűségi eloszlás információk tárolása a rendszerben. Nem rendelkeznek bias értékekkel. </li></ul><p> </p><h2>Visszacsatolt neuron struktúrák </h2><p>Vannak feladatok, ahol a minták egymásutánisága fontos plusz információt hordoz. Időbeli sorozatok modellezésénél fordul elő. Pl. beszédfelismerés, nyelvi feldolgozás, videók elemzése Módosítani tudjuk a hálót, hogy a szomszédokat is figyelembe vegye: </p><ul><li>Előre csatolt háló több szomszédos inputon: Time-delay neural network </li><li>Visszacsatolt háló: recurrent neural network </li><li>Visszacsatolt háló, hosszú távú memóriával: Long short-term memory network </li></ul><p> </p><ul><li>Rekurrens neuronok: Jellemző a ReLU aktivációs függvény és a bias érték használata. A hálózat egymást követő számítási ciklusai során a korábbi eredményt is felhasználja. Lényegében egy egyszerűbb rövidtávú memória. </li></ul><p> </p><ul><li>Fejlett rekurrens neuronok: Hosszú rövidtávú memória (Long Short Term Memory). Kapuzott visszacsatolt egység (Gated Recurrent Unit). Az egyszerű rekurrens hálók korlátozott </li></ul><p>memóriaképességeinek leküzdésére hozták létre. Összetett architektúrával rendelkező megoldások. A </p><p>tárolt információ fejlettebb kezelésére külön bemeneti csatornákkal rendelkeznek. </p><p> </p><h2>Long Short Term Memory – LSTM </h2><p>Egy külön belső állapotot hozunk létre, amely memóriaként fog működni. Az információ párhuzamos útvonalon fog áramlani. </p><ul><li>Forget gate: Mely komponenseket kell elfelejteni a C memóriából. - 	Input gate: Mely input komponenseket kell eltárolni C-be </li><li>Output gate: Hogyan álljon össze a kimenet. </li><li>A memória frissítése a forget gate és az input gate segítségével.  </li></ul><p> </p><h2>LSTM vs. GRU </h2><p>A GRU kevesebb kaput használ, de a tapasztalatok szerint könnyebben, gyorsabban tanítható és hasonló pontosságra képes, mint az LSTM. A kevesebb kapu miatt egyetlen GRU egység kevesebb egyenlettel írható le, mint az LSTM. </p><h2>Modern architektúrák </h2><ul><li>Mély előre csatolt: Deep Feed Forward, DFF architektúra. Lényegében egyszerű, általánosított többrétegű perceptron háló. Jellemzően ReLU, vagy nem lineáris aktivációs függvényeket alkalmaznak. A mély jelzőt annak köszönheti, hogy legalább két rejtett réteg található benne. Már régebben is számos rendelkezett ilyen és még bonyolultabb struktúrákkal, de akkoriban nem tüntették ki ezeket külön a mély megnevezéssel. Jellemző a teljes összecsatolás a rétegek között. Számos változata van a gyakorlatban. </li><li>Konvolúciós neurális hálózatok: Convolutional Neural Networks. Mély előre csatolt hálózat. </li></ul><p>Bemeneti rétege és az első rejtett rétege között konvolúciós és pooling neuronokat tartalmazó rétegek helyezkednek el. Célja a bemeneti adat különböző részeire vonatkozó jellemzők kinyerése és az információ szűrése. Leggyakrabban a gépi látás területén alkalmazzák, de használják </p><p>hangfeldolgozásra is. A konkrét megvalósítások az architektúra részleteiben, számítási igényben és pontosságban eltérnek, azonban az alap koncepció egységes. </p><ul><li>Hopfield hálózatok: Visszacsatolt neurális hálók. Minden egyes neuron kimenete összeköttetésben áll az összes többi neuron bemenetével. Minden neuron emiatt kimeneti és bemeneti is. Kiválóan alkalmas az önszervező tanulásra. A rendszert mintákkal kell ellátni, amely értékeinek megfelelően módosul a hálózat, majd konvergál az ideális értékhez. Jellemzően egyrétegű hálózatként ábrázolják. </li><li>Markov láncok: A Hopfield hálók egy speciális változata. A klasszikus értelemben nem neurális háló. Markov láncok, ahol a teljes összeköttetésben álló neuronok probabilisztikusak. Azt modellezi, hogy egy adott állapotból mekkora a valószínűsége egy második állapotba való váltásnak. </li><li>Boltzmann gépek: Boltzmann Machine – BM. Hopfield hálók egy speciális változata. Egyes neuronok dedikáltan bemeneti neuronok, míg a többi rejtett neuron. Egy teljes hálózati lefutást követően a bemeneti neuronok kimenetivé válnak. A neuronok jellemzően bináris jellegűek.  </li></ul><p> </p><p>Gyakrabban használt változata a korlátos Boltzmann gép. Annyiban különbözik az eredeti koncepciótól, hogy a ki/bemeneti neuronok és a rejtett neuronok elkülönülő réteget alkotnak. A rétegen belül nincs kapcsolat a neuronok között. </p><ul><li>Autóenkóderek: Autoecnoder – AE. Egy speciális előre csatolt háló. Célja az információ kódolása asszociáció révén. A variációs autóenkóder az autóenkóderek egy speciális változata. Más megközelítést alkalmaz. A bemenetek közelítő valószínűségi eloszlásain alapul, valószínűségi rejtett neuronokkal. Elméleti háttere a Bayes-i matematikára és a Boltzmann gépekre vezethető vissza. </li><li>Mély bizonyosságháló: Deep Belief Network – DBN. A variációs autóenkóderekhez és a korlátos Boltzmann gépekhez is kapcsolható architektúra. Egyik legelterjedtebb nem konvolúción alapuló mély architektúra volt. Generatív modellnek tekinthető. Egyaránt alkalmas osztályozási feladatokra és nem felügyelt tanulással új adat generálására. Az egyes rétegek hatékonyan taníthatóak különkülön is, mohó megoldás segítségével. Tudatosan rétegenkénti lokális optimumok révén próbál elérni egy kvázi optimális modellt. </li><li>Generatív versengő hálók: Generative Adversarial Network – GAN. Hibrid megoldás. Két hálózatból </li></ul><p>áll: Generátorból és diszkriminátorból. A generátornak mintákat kell előállítania, a diszkriminátornak a generált és a valós mintákat kell megkülönböztetnie. Cél, az eloszlás megtanulása és abból példányok generálása. A generátor és diszkriminátor egy zéró összegű játék két szereplője. Hamisító és rendőr. Az ilyen hálózatok összehasonlítása nehéz, mert mindig csak két háló egymáshoz viszonyított teljesítményét látjuk. Az ilyen hálózatok kezelése, tanítása komoly kihívást jelenthet. A részhálók tanítását és működésük összehangolását egyaránt meg kell valósítani a lokális optimumokban való ragadás nélkül. Kiválóan alkalmas élethű képek generálására. Számos változat elterjedt belőle, leggyakrabban a különböző képek és videók generálására használják. </p><p> </p><h2>Konvolúciós neurális hálókról részletesen </h2><p>Első rétege mindig egy konvolúciós réteg. Feladata az alacsony szintű tulajdonságok detektálása. Pl. élek, görbék. További konvolúciós rétegek feladata: Magasabb szintű jellemzők detektálása. A magasabb rétegek egyre komplexebb, egyre absztraktabb fogalmakat tanulnak meg. Pl. szem, orr, arc. </p><p>A konvolúciós réteg neuronjai átalakítják a bemenetet annak érdekében, hogy kiemeljék a fontosabb jellemzőket rajta. Ezt az átalakítást egy kernel segítségével végzik. A kernel konvolúciós mátrix néven is ismert. A kernel egy súlyokat tartalmazó, kis méretű mátrix. Három dimenzió esetében magasságát és szélességét tekintve kisebb, mint a bemeneti mátrix, melyen a konvolúciót végezzük, viszont mélységükben megegyeznek. A konvolúciós művelet a kernelben található súlyértékek felhasználásával alakítja át a bemenetet, a kernelt a bemeneti képen függőleges és vízszintes irányokban végig csúsztatva. Így kerül kiszámításra a konvolúciós réteg egy neuronja által előállított aktivációs térkép. </p><ul><li>Konvolúciós réteg: Pl. bemeneti kép 32x32x3 pixel, a kernel 5x5x3, ekkor a kimeneti aktivációs térkép 28x28-as méretű </li><li>Összevonó réteg: Jellemzően a konvolúciós rétegek után alkalmazzuk őket a folyamatos dimenziócsökkentésre, ezáltal a számítások redukálására szolgál. Egy mintavételt a konvolúciós réteg eredményén, a konvolúciós réteg mögött szoktuk alkalmazni. Általában átlagot, maximumot vagy minimumot számolunk. </li><li>Teljes összekapcsolt réteg: A hálózat végén szerepel. A réteg minden neuronja minden előző réteg neuronjával összeköttetésben áll, ezáltal a felsőbb rétegek aktivációs térképeinek eredményét levetíti az ezt követő, klasszifikációs feladatot megoldó rétegekre. </li></ul><p> </p><h2>Hopfield hálózatról részletesen </h2><p>Az alapmodell esetében a Hopfield hálózat neuronjai kétértékűek. A hálózat bemenetének a neuronok kezdeti állapotai tekinthetők, míg a kimenetet ugyanezen neuronok állapotai jelentik a működés során. A hálózat tanítása a megjegyzendő minták tárolásával történik. A megfelelően beállított súlyokkal rendelkező hálózattól azt várjuk, hogy az adott kezdeti konfigurációból kiindulva az ehhez legközelebbi vonzási pontba stabilizálódik. Ezt hívjuk energiaminimumnak. </p><p>A hálózat működtetésének alapvetően két módja van: </p><ul><li>Szinkron: Az összes neuront minden időlépésnél egyszerre módosítjuk. A rendszer bármely állapotváltozás során a konfigurációs tér bármely pontjába kerülhet. </li><li>Aszinkron: Egy pillanatban csak egy egység válthat értéket. A hálózat szomszédos konfigurációkon keresztül jut el a vonzási pontba.  </li></ul><p>Alkalmazás: Bináris minták tárolása; hibás, zajos, hiányos minták helyreállítása, felismerése </p><p> </p><p><strong>Boltzmann gépekről részletesen:  </strong></p><p>Két rétege van:  </p><ul><li>Látható réteg: Ez egyszerre az input és az output réteg, ami bináris kimeneti értékeket ad. - Rejtett réteg </li></ul><p> </p><p>A korlátos Boltzmann gépek tanítása: Paraméterek meghatározása, amelyek minimalizálják az energiafüggvényt az adott inputra. </p><p>Alkalmazások:  </p><ul><li>Dimenziócsökkentés </li><li>Osztályozás </li><li>Regresszió </li><li>Kollaboratív szűrés </li></ul><p> </p><h2>Neurális hálók tanítása </h2><p>A gépi tanulás a mesterséges intelligencia egyik ága. Nem része a mesterséges neurális hálók területének, de elengedhetetlen segítője. Az architektúrák ideális paraméter értékeinek felügyelt és nem felügyelt tanulással való meghatározása a cél. Mély architektúrák és számos formában előfordulhat. A konkrét megoldások jellemzően az alkalmazási területhez köthetőek. A tanítási módszertől függetlenül különösen fontos a megfelelő mintakészlet kialakítása. A legtöbb mélytanuló megoldás nagy mennyiségű adatot igényel. Gyakran a neurális hálózatokon alapuló modellek fejlesztési idejének nagyobb részét teszi ki a minták előkészítése, mint a hálózat felépítése. A neuronok bemeneteihez rendelt súlyok ideális értékeinek meghatározása. A hálózat elvárt és valós kimenetei közötti különbség által számított E hiba vagy költségfüggvény segítségével történik. A cél olyan súlytényező értékek megtalálása, amikkel a háló a legkisebb hibát éri el. </p><h2>Perceptron Learning Rule </h2><p>Perceptron tanulási szabály. Egyszerű perceptron hálóknál alkalmazzák. Gradiens alapú megoldást használnak, minden esetben a hibafüggvény lehető legnagyobb csökkenésének irányába viszi el a paramétert a lokális optimumot garantálva. A módosításhoz használt érték meghatározására a hibafüggvény deriváltját használjuk az adott súlytényezők mellett. Csak a klasszikus küszöbfüggvényt alkalmazó hálózatok esetében használható. </p><h2>Delta Learning Rule </h2><p>Hasonlít a Perceptron tanuláshoz. Az eltérés, hogy az aktivációs függvény tetszőleges differenciálható függvény lehet. Hívják még Widrow-Hoff tanulási szabálynak is. A modern megoldások egy speciális esete. Nagy előrelépést jelentett a bonyolultabb aktivációs függvényeket alkalmazó hálózatok területén. Több réteggel rendelkező topológiák esetén nem volt alkalmazható. <strong>Backpropagation </strong></p><p>Szintén a gradiens módszer segítségével minimalizálja a hibafüggvény értékét. Alkalmas többrétegű neurális hálók kezelésére. Hatékonysága abban rejlik, hogy a hibát a hálózat rétegjein külön-külön vezeti vissza. Ennek megfelelően módosítja a súlytényezőket és a láncszabály elvét veszi alapul. Felügyelt tanítási módszer, de alkalmazzák nem felügyelt tanításra is. </p><p>A gyakorlatban a hibafüggvény meghatározására összetettebb függvényeket alkalmaznak, mint pl. a kereszt entrópia, logit, precision. Sztochasztikus gradiens módszereket szoktak alkalmazni, pl. Adam keresés. </p><p>Fő lépései: </p><ul><li>Tanítási minta kiválasztása </li><li>Minta előre terjesztése </li><li>Kiértékelés és hiba kiszámítása: Elvárt és eredmény kimenetek közötti eltérés - 	Hiba visszaterjesztése </li><li>Módosított súlytényező kiszámítása </li><li>Súlytényezők módosítása </li></ul><p>A lépéseket addig ismételjük a tanítási mintákra, míg a hiba a kívánt tartományba nem esik. </p><h2>Neurális hálók tanításának kulcsfogalmai </h2><p>Modern mély tanulási keretrendszerek: Pl. TensorFlow, minimális kódméret, egy egyszerű függvényhívás segítségével tanítható, egyszerű prototipizálásra alkalmas megoldás. A mélyben zajló folyamatok megértése  Minta – Sample: Egy konkrét bemenet a hálózat számára. </p><p>Tanítási minta – Training Sample: Kimondottan a hálózat tanítására szolgáló minta, jellemzően ez felügyelt tanítás esetén együtt jár a hálózat elvárt kimeneti értékével.  </p><p>Validációs minta – Validation Sample: A neurális hálózat által megtanult modell tesztelésére szolgáló, a tanítási minták között nem szereplő minták. </p><p>Mintakészlet – Sample Set: A minták gyűjteménye </p><p>Szakasz – Epoch: A teljes mintakészlet egyszeri átadása a hálózat számára. </p><p>Soros vagy szekvenciális tanítás – Sequential Learning: Online típusú tanítás, amikor minden egyes mintát követően hangolásra kerülnek a hálózatban használt súlyok. </p><p>Köteg – Batch: Offline típusú tanítás esetén a súlyok a minták egy csoportja alapján kerül módosításra, nem pedig a mintánként a soros tanítástól eltérően. </p><p>Kiesés vagy elhalálozás – Dropout: Amikor a tanítási folyamat során valamilyen okból kifolyólag neuronok kapcsolódását reprezentáló súlytényezők nulla értéket vesznek fel, vagyis a hálózat nem veszi figyelembe annak az értékét, azaz, kimarad a számításból. Esetenként ez lehet kívánatos, de elkerülendő is amit az aktivációs függvénnyel, illetve a tanuló algoritmus megfelelő paraméterezésével küszöbölnek ki. </p><p>Túltanítás vagy túlillesztés – Overfitting: Amikor a modell nem valós összefüggéseket is megtanul. Túl jól illeszkedő megoldást talál, ami általános esetekre vonatkozóan azonban már nem teljesít megfelelően. </p><p>Alultanulás vagy alulillesztés – Underfitting: Akkor jelentkezik, amikor nem megfelelő a hálózat mérete. </p><p>Regularizálás: A túltanítás elkerülésére alkalmazott technikák. A cél a megtanult modell általánosítása. </p><p>Generalizálás: A neurális hálók alapvető képessége a mintákból való általánosított jellemzők megtanulása. Tanulási sebesség – Learning Rate: A súlytényezők módosításának mértékét befolyásoló paraméter. Kicsi érték esetén a tanulás lassú, de stabilan konvergál. Nagy érték esetén a tanulás gyors, de előfordulhat, hogy nem konvergál. Általában az értékét fokozatosan csökkentik. </p><p>Hiper-paraméterek – Hyperparameters: A hálózatra jellemző paraméterek. A struktúrát írják le, pl. rétegek és az azokban található neuronok száma, vagy a tanulási sebesség. </p><p>Adat dúsítás – Data augmentation: A mély tanulási módszerek hatalmas adatigénye. Gyakori problémát okoz az olyan területeken, ahol az adatgyűjtés költséges, vagy nehezen megoldható. A meglévő mintákból új mintákat állítunk elő és ezeket is felhasználjuk a tanítás során. </p><p>Egy lövéses tanulás – One Shot: Egyetlen minta alapján képesek a neurális hálózat paramétereit hangolni. Egy kutatási irány a hiányos adathalmazok orvoslására. </p><p>Átadásos tanulás – Transfer Learning: Olyan technikák, amelyek egy már valamilyen mintakészlet alapján betanított hálózatot használnak fel. Lényegében a forrásként használt modellben található tudást adja át az új hálózatunknak. <strong>Gépi látás </strong></p><h2>Alkalmazások </h2><ul><li>Speciális effektek </li><li>3D modellezés </li><li>3D rekonstrukció </li><li>Biometrikus azonosítás </li><li>Karakter felismerés </li><li>Vizuális keresés mobiltelefonnal </li><li>Önvezető autók </li><li>Vizuális alapú interakciók </li><li>Kiterjesztett valóság </li><li>Virtuális valóság </li></ul><p> </p><h2>Emberi látás </h2><p>A fény útja a szemben: </p><ul><li>A fény a szaruhártyán megtörve jut a szembe, ez lényegében egy fény gyűjtőlencse. </li><li>A szivárványhártya csökkenti a szembe jutó fény mennyiségét, a pupilla pedig fényreteszként funkcionál. </li><li>A szemlencse a második gyűjtőlencse, a belépő fénysugarakat a retinára fókuszálja. </li><li>A retinában a kétféle fényérzékelő sejtek közül a csapok képesek felismerni a színeket. </li><li>A különböző csapok három alapszín felismerésére képesek: vörös, zöld és kék. A különböző színárnyalatok felismerése ebből a 3 alapszín keveréséből alakulnak ki. </li><li>Az érzékelő elemekhez idegek kapcsolódnak, az ingereket a szemidegen keresztül az agy felé továbbítják. A látás érzékelő elemei az esti fényben működő mintegy 130 millió pálcika és a nappali fényben működő mintegy 7 millió csap. </li><li>Az esti látás elemei a pálcikák nem látnak színeket, de rendkívül érzékenyek. </li><li>A nappali látás elemei a csapok, kevésbé érzékenyek és színesen látnak, mert a csapokban három különböző pigment található, melyek egyike a vörös, másik a zöld, a harmadik pedig a kék fényre érzékeny. </li></ul><p> </p><p>A különböző hullámhosszú fény másképp törik. Ahhoz, hogy a szemlencse ezeket is a retinára tudja fókuszálni, a sugárizomnak módosítania kell a szemlencse alakját. Ugyanaz történik, mint amikor közelre vagy távolra nézünk. A piros szín azért kelt közelség érzetet, mert ugyanaz játszódik le piros felületre fókuszáláskor, mint amikor közelebbre nézünk. Kék színnél pedig ugyanaz játszódik le, mint amikor távolabbra nézünk, ezért kel tágasabb érzést.  </p><p>Amikor fény ér egy fotóreceptort egy kémiai reakció indul el, aminek eredményeképp egy neurális jelet küldenek az agy felé. Ha egy csap egy adott hullámhosszra 30%-ban érzékeny, az azt jelenti, hogy átlagosan 10-ből 3-szor fogja abszorbeálni az olyan hullámhosszú fénykomponenst és küld jelet az agy felé. A fényreceptorok észleléseit a látóideg továbbítja az agy felé. A látóideg csatlakozási pontja a szemgolyóhoz a vakfolt, itt nincsenek sem csapok, sem pálcikák. A látógödör, ami a vakfolttól oldalra található, az éleslátás helye. A közepe a foveola, ahol csapok találhatóak kizárólag. A foveolától kifelé haladva a csapok egyre ritkábbak és a pálcikák váltják fel őket. </p><p> </p><h2>Elektromágneses spektrum </h2><p>A fény a teljes elektromágneses spektrumtartomány látható része, amelyet hullámhosszával jellemezhetünk. A látható fény 380-780 nm hullámhossztartományba esik. Az egyes hullámhosszoknak a színek felelnek meg. A különböző hullámhosszúságú fotonok más és más érzetet keltenek a szemlélőben, ezt az érzetet hívjuk színeknek. </p><h2>Út az agyba </h2><p>Agy felé küldött információ nem egyszerűen a háromféle csap által leadott jel. Ehelyett az S, M, L csapok által leadott jelek összege vagy különbsége indul az agyba. Háromféle idegkötegen halad a színinformáció:  </p><ul><li>A=M+L: Az M és az L csapok által adott válaszok összege, az akromatikus csatorna. </li><li>R/G = M-L: Vörös-zöld különbség. </li><li>B/Y = S-A: A kék és az akromatikus csatorna különbsége. </li></ul><p> </p><p>Az agy felé továbbított csatornák azt is befolyásolják, hogy egy adott színt mennyire tartunk telítettnek. Nagyjából a színt érzékelő kromatikus csatornák és az akromatikus csatorna válaszának aránya határozza meg ezt. Ezért is van, hogy a sárgát pl. nem tartjuk annyira telítettnek, mint akármilyen pirosat vagy kéket. </p><h2>Színek a számítógépen </h2><p>1931: Hogyan lehetne egy általános leírást adni arra, hogy egy ember miképp érzékeli a színeket? A kísérletek egyik eredménye volt, hogy bármilyen szín előállítható három, megfelelő szín keverékeként, vagyis bármely színérzet kódolható egy számhármassal, tristimulus értékkel. </p><h2>Színterek </h2><p>A színterek a színek ábrázolására használható virtuális térbeli koordináta rendszer, ahol az egyes színek tulajdonságait azok koordinátái fejezik ki. </p><ul><li>RGB színtér: 1931-ben volt az additív színmegfeleltetés alapkísérlete. Minden színinger létrehozható 3 egymástól független színinger additív keverékeként. A függetlenség alatt azt értjük, hogy a három színinger közül egyik sem hozható létre a másik kettő additív keverékeként. Az RGB színtér egy olyan additív színmodell, ami a vörös, zöld és kék fény különböző mértékű keverésével határozza meg a különböző színeket. Az elnevezése ennek a három színnek az angol megfelelőiből ered: Red, Green, Blue. Az RGB skálán egy színt az határoz meg, hogy milyen intenzitású a három komponense. Egységnyi alapszíneket összekeverve, fehéret kapunk. </li><li>CIE XYZ színtér: Az RGB térrel az első problémát az jelentette, hogy negatív koordinátákra is szükség volt, bizonyos hullámhosszú monokromatikus fény érzékeléséhez hasonló fényérzet kialakításához. XYZ színtér azt jelenti, hogy látható spektrumbeli fények csak pozitív súlyokkal kikeverhetőek. </li><li>HSV színtér: A cél, hogy a színkoordináták az ember által érzékelt szubjektív fogalmakhoz adaptáltak legyenek. Világosság (Lightness – L, vagy Value - V): 0 és 100 százalék között, 0 a teljesen fekete legalsó végpont, fehér a legfelső végpont. Színezet (Hue - H): A szám 0 és 360 fok között van kifejezve. Telítettség (Saturation - S): 0 és 100 százalék között mennyi szürkét tartalmaz, ha telítettebb élénkebb. A három színjellemzőt egy henger terében lehet a legszemléletesebben ábrázolni. A színezet a henger főkörén fut körbe. A telítettség sugárirányban változhat. A világosság a henger tengelyének irányában helyezkedik el. </li></ul><p> </p><h2>Digitális képfeldolgozás </h2><p>A számítógép a képi információkat is digitális adatokként kezeli, így a kép minden jellemzőjéhez valamilyen számot rendel. Pixel: A kép legkisebb egysége. Minden képpont elérhető a koordinátája alapján. </p><p>Digitális kép típusai:  - 	Vektorgrafikus kép: A megjelenített kép elemeit a számítógép matematikailag leírható vonalakra és göbékre bontja, majd ezek egyenleteit tárolja. Az árnyalatokat nehezen kezeli, azonban nagyításkor a felbontás nem romlik, mivel csak a csomópontok koordinátái változnak, maga a képet leíró függvény nem. - 	Pixelgrafikus kép: Képpontokból áll, jellemző a képpontok és a színek száma.  Alapegysége és a felbontás egysége is a pixel. A képek külön tárolt képpontokból épülnek fel. Minden képpont tulajdonságát numerikus értékek határozzák meg, ez a színmélység. Korlátlan színhasználat lehetséges. A pixelméret csak bizonyos határok között módosítható. A képméret változásakor minőségromlás következik be. A képeknek nagy a helyigénye. A felbontás a Dot Per Inch – DPI. Ha </p><p>egy kép pl. 300DPI-s, akkor 1 inch hosszon 300 képpontból áll. A felbontás növelésével a kép mérete négyzetesen nő. </p><p> </p><h2>Képábrázolási módok </h2><ul><li>Bittérképes kép: Az egyes képpontokhoz tartozó információt egy bit hordozza. </li><li>Szürkeárnyalatos kép: Csak a szürke és árnyalatai jelenhetnek meg egyszerre, legfeljebb 256 árnyalattal. A kép pontonként 8 biten ábrázolható. </li><li>Színes kép: Pixelenként 3 db érték. Pl.: RGB, HSV </li></ul><p> </p><p><strong>Hisztogram </strong></p><p>Annak ábrázolása, hogy adott pixelértékek milyen gyakran fordulnak elő. </p><h2>Gépi látás folyamata </h2><ul><li>Alakzatok: </li></ul><p>o Él: Egy nagyobb, a kontúrra merőleges intenzitás-változás o Sarok: Egy hirtelen forduló a kontúron o Vonal: Egy keskeny, hosszú régió o Folt: Egy kompakt régió </p><p> </p><ul><li>Előfeldolgozás: Bemenet és a kimenet is egy-egy kép. Feladatok: Felesleges információk eldobása, átalakítása szürkeárnyalatos képpé. Zajszűrés, élesítés, kontraszt erősítése. </li><li>Zajtípusok:  o Additív képfüggetlen, azaz fehér zaj: g(x, y) = f(x, y) + v<sub>add</sub>(x, y), ahol f(x, y) az inputkép, g(x, y) az outputkép, v(x, y) a zaj. Ez a tipikus csatornazaj.  <ul><li>Nem korreált multiplikatív zaj: g(x, y) = f(x, y) * vmult(x, y), ez a televíziós rasztersorokra jellemző amplitúdó moduláció. </li><li>Kvantálási zaj: vkvant(x, y) = gkvant(x, y) – feredeti(x, y), az eredeti jelérték folytonos, a kvantált jelérték diszkrét, a különbség véletlen zajként jelenik meg.  </li><li>Só és bors zaj: Ez a pontszerű, a képpel nem korreáló, véletlen zaj legtöbbször szélsőértékű. Jellemző egyes űrfelvételekre. </li></ul></li><li>Képszűrés: A digitális képfeldolgozás központi fogalma és legfontosabb művelete. A képtérben működők közvetlenül a képértékkel operálnak. Más térben működők pl. a frekvenciatartományban operálnak.  <ul><li>Lokális operátorok: Legyen f(x, y) a bemeneti kép, g(x, y) a kimeneti kép. Az (x, y) pontban az eredmény csak a pont környezetétől függ: g(x, y) = T(f(x, y)), ahol a T a környezeten definiált operátor. </li><li>Rekurzív operátorok: Az aktuális eredmény a bemenettől és az előző eredményektől is függhet. A kimenet nincs elválasztva a bemenettől, és az operátor működése során a bemenet módosul, mert a bemeneti képmátrixba írjuk be az eredményt. Ennek a hatása annál jelentősebb, minél nagyobb a környezet, az ablak. </li><li>Nem rekurzív operátorok: Az eredmény csak a bemenet aktuális környezetétől függ. A kimenet el van választva a bemenettől, és a működés során a bemenet nem módosul, így a művelet hatása korlátozódik a környezetre. </li></ul></li></ul><p> </p><p>Képszél probléma kezelése: Heurisztikus megoldások vannak rá: </p><ul><li><ul><li><ul><li>Töltsük ki nullákkal: Ez a legegyszerűbb megoldás, amely azonban nemkívánatos, erős mesterséges éleket eredményezhet. </li><li>Töltsük ki az eredménykép átlagértékével: Kevésbé erős mesterséges éleket kaphatunk és nem változtathatjuk meg az eredménykép értéktartományát. </li><li>Töltsük ki a legközelebbi kiszámított pixelértékkel: Akkor célszerű alkalmazni, ha </li></ul></li></ul></li></ul><p>minden áron el akarjuk kerülni a mesterséges élek megjelenését. </p><p> </p><p>Átlagszűrők típusai:  </p><ul><li><ul><li><ul><li>Dobozszűrő: A legegyszerűbb és a leggyorsabb, azonos súlyokkal rendelkező átlagszűrő. Egy (2M + 1) x (2N + 1) -es méretű ablakban az eredmény a képérték egyszerű, nem súlyozott átlaga. </li><li>Gauss szűrő: Legelterjedtebb átlagszűrő. Súlyokat a normálelosztás adja. A maszkja körszimmetrikus, mert csak az r-től függ. Az exponens miatt a maszk harangalakú, a σ paraméter szabályozza a szűrő méretét. Nagyobb σ nagyobb szűrőt és erősebb simítást eredményez. </li><li>Simítószűrés: Simítószűrővel zajszűrést elsősorban a nulla átlagú fehér zaj esetében végezhetünk, mert átlagban az ellenkező előjelű zajok véletlenszerűen semlegesítik egymást. Minél nagyobb a szűrő, annál nagyobb a semlegesítés valószínűsége és a zajcsökkentés mértéke. Vannak azonban negatív mellékhatásai, a kontrasztcsökkentés és az él elmosódás. Alul mintavételezésre és a felbontás csökkentésére egyre nagyobb Gauss szűrőt alkalmazzunk egy képre, a finom részletek egyre jobban tűnnek el, majd szűrés után minden 2. oszlop és sor törlése történik. Képpiramis jön létre. A mértéktér felépítése egy kép Gauss szűréssel nyert képsorozatból áll növekvő σ mellett. Ez az adatstruktúra hatékony, változó részletességű képelemzést tesz lehetővé. Hibás bemeneti értékek nagy mértékben befolyásolhatják az eredményt. A hibás bemeneti értékek a normális zajszinten felüli, teljesen hibás adatok. </li><li>Mediánszűrő: A mediánszűrő eredménye az ablakban lévő értékek mediánja. A medián meghatározása nem lineáris művelet P és Q számsorozatra. Az átlaggal ellentétben a medián robosztus statisztikai mennyiség. Ha a hibás adatok aránya kevesebb mint 50%, nem befolyásolják az eredményt. A mediánszűrő eltávolítja a só és bors zajt úgy, hogy nem mossa az éleket és nem csökkenti a kontrasztot. A mediánszűrő törli a vékony vonalakat, ha a vonalvastagság kevesebb mint a szűrőméret fele. Ilyenkor a háttérpixelek többségben vannak az ablakban és ők adják a mediánt. A mediánszűrő lekerekíti a sarkokat. A vektoros mediánszűrőt vektormezők javítására és simítására használják. A szűrő módosítja a hibás vektorokat, amelyek elütnek a környezettől. Iteratív alkalmazásával elsimítjuk a vektormezőt. </li><li>Laplace szűrő: A deriváltakat különbséggel közelítjük. Az eredmény közel áll az eredeti és a simított kép különbségéhez. A lassú képváltozásokat levonjuk, a gyors változások megmaradnak. Ha nincs változás, nulla az eredmény. A kimeneti kép értéktartománya elvileg [-255, 255]. Egy pixel és a szomszédjai különbsége azonban gyakran kicsi, ezért a gyakorlatban az értéktartomány lényegesen szűkebb. A Laplaceszűrő kiemeli az intenzitás változásokat és a finom részleteket. Kontúrokat, foltokat, vékony vonalakat. A szűrő zaj-érzékeny, mert magasrendű deriváltakat tartalmaz. Egy simítószűrőt alkalmazhatunk előtte, hogy a képfüggvény deriválható legyen. Az eredmény negatív is lehet. Két lehetőség van, abszolútértékes leképezés. Itt elveszítjük az információ egy részét, mert elvész a változás előjele. Viszont jól láthatjuk azokat a részleteket, ahol finom változások vannak. A másik verzió a normalizált érték leképezés. Itt az értéket leképezzük a [0, 255] tartományra és így ábrázoljuk az eredményképet. Ez nem jár információ veszteséggel, de gyakran kevésbé szemléletes képet eredményez. Laplacian of Gaussian szűrő: A Laplace és a Gauss szűrő kombinációja. A Gauss szűrő alkalmazása után a képfüggvény simább, deriválhatóbb lesz, ezért wlog kevésbé zajérzékeny. wLoG = wG * wL </li></ul></li></ul></li><li>Éldetektálás: Egy gyakori képfeldolgozási feladat, amely segítségével be tudjuk határolni a képen </li></ul><p>látható régiókat, tárgyakat. Az él egy nagyobb, kontúrra merőleges, intenzitás változás. </p><p> </p><p>Éldetektálás folyamata:  </p><p>o Élszűrés: Élszűrő élekre reagál, vagyis felerősíti az éleket és elnyomja a kis változású régiókat. Az élszűrők a képfüggvény deriváltjait alkalmazzák, hogy felerősítsék az élre merőleges intenzitás változásokat és elnyomják az ilyen változásokat nem tartalmazó régiókat. Leggyakoribb operátorok a gradiens és laplace operátor.  </p><p> </p><p>A jó lineáris élszűrő kritériuma, hogy legyen nulla az eredmény ott, ahol nincs képváltozás. Legyen jó a detektálás, azaz legyen minimális a hamis, zajos élek detektálása és a valós élek elvesztése. Legyen jó a lokalizálás, a detektált él a lehető legközelebb legyen a tényleges élhez. A szűrő legyen izotróp, az eredmény ne függjön az él orientációjától. A szűrő egy élet csak egyszer jelezzen, legyen minimális a valós él körüli hamis lokális maximumok száma. </p><p> </p><ul><li><ul><li>Éllokalizáció: Utófeldolgozás eltünteti a zajos fantom képeket. </li></ul></li></ul><p>Egy zajos, elmosott él több szomszédos maximumot produkál. A legkisebb méretű 3x3-as gradiensszűrők esetén a parciális deriváltakat különbségekkel közelítjük, ezzel az X és Y irányú, Gx és Gy deriváltmaszkokat kapjuk: f * G<sub>x</sub> = f<sub>x</sub>, f * G<sub>y</sub> = f<sub>y </sub>- 	Szegmentálás: Fontos területek kiválasztása, a kép érdekes és érdektelen részeinek meghatározása. Legtöbbször szín és világosság alapján történik. Navigációs alkalmazásoknál pl. nem érdekes az égbolt. </p><ul><li><ul><li>Intenzitás alapján küszöbözéssel a nagy homogén területek egyenletes intenzitás értékek. o Régió alapú szegmentálás: A szegmentálás eredménye függ attól, hogy milyen képi tulajdonságokat használunk pl. intenzitás, szín, textúra. Függ attól hogy hogyan hasonlítjuk össze a tulajdonságokat és hogy mekkora változásokat tolerálunk a régión belül. </li></ul></li></ul><p> </p><p>Pixel felhalmozás: Régió alapú szegmentálási eljárás. </p><p>Vágás és egyesítés: </p><ul><li><ul><li>Fentről lefelé: Felosztjuk a képet egyre csökkenő méretű Ri kockákra. Megállunk, ha az összes kocka homogén. P(Ri) = TRUE. Az eredmény egy négyesfa. </li><li>Lentről felfelé: Minden szinten egyesítünk lét szomszédos Ri <sub>és </sub>Rj régiót. P(Ri U Rj) = TRUE o Iteráljuk a két fázist, amíg van új felosztás vagy egyesítés. </li></ul></li></ul><p> </p><p>Egyéb szegmentálási módszerek: </p><ul><li><ul><li>Él alapú: Objektumok kontúrkeresése élkövetéssel. o Textúra, szín alapú: Régiók textúráját, színét használják. o Mozgás alapú: Objektumok szegmentálása mozgás alapján. </li></ul></li></ul><p> </p><ul><li>Objektum felismerés: Különböző feladatok, mint osztályozás, ami azt jelenti, hogy a kép tartalmazza-e a keresett objektumot? Kép keresés Pl. Google Fotók. Detektálás, ami szerint hol található a keresett objektum a képen? Geometriai és szemantikai tulajdonságok kinyerése. Pl. két tárgy távolsága.  <ul><li>Osztályozás: Minden képhez egyetlen címke tartozik.  Azaz, a képen egyetlen objektum látható és az az egész képet betölti, ezért a feladatot osztályozási feladatként lehet meghatározni. </li><li>Osztályozás + lokalizálás: Egyetlen objektum nem tölti ki a teljes képet vagy több objektum van a képen. </li></ul></li></ul><p>Az osztálycímke diszkrét érték, vagy eltaláltuk vagy nem. A befoglaló téglalap valóditól való eltérése viszont folytonos érték. A pontossága mérésére az intersection over union (IoU) értéket szokás használni. Általában akkor tekintjük helyesnek a detektálást, ha a címke helyes és IoU&gt;=0,5. Párhuzamosan kell elvégezni az objektumok osztályozását és detektálását. A probléma, hogy az összes lehetséges pozíciót és ablakméretet végig kellene próbálni, túl sok a lehetőség. </p><p> </p><p>R-CNN: Ez egy hierarchikus képszegmentáló-klaszterező algoritmus, amely képenként kb. 2000 régiójavaslatot állít elő. A javasolt régiókat egységes méretűre konvertáljuk. 3 különböző tanuló algoritmusból áll, ezek külön vannak tanítva. Ezeket egy CNN segítségével feldolgozzuk. Az osztályozást egy lineáris SVM-el végezzük. A régiók utólagos pontosítása is lehetséges.  </p><p> </p><p>Fast R-CNN: Az R-CNN modellhez képest két módosítást javasoltak. Az egyik, hogy a három tanulót egyesíteni egyetlen tanulómodellé. Ehhez csak az SVM-et kellett lecserélni egy fully connected osztályozó rétegre. A másik, hogy az R-CNN lassú, mert egyetlen képen 2000x kell lefuttatni a CNN jellemzőkinyerést. A Fast R-CNN-nél nem kell minden régióra külön kiszámolni a CNN részt. </p><p>A teljes képet ráeresztjük a CNN-re egyszer, majd a kapott konvolúciós jellemzőkből vágjuk ki az egyes régiókat leíró részeket. ROI Polling Layer: 7x7-es tulajdonság térkép kinyerése minden ROI régióhoz. </p><p>Faster R-CNN annyival gyorsabb az R-CNN-nél, hogy a futási időt itt már a régiójavasló algoritmus dominálja. A Faster-CNN megpróbálja a régiójavaslatokat is egy neuronháló segítségével előállítani. Ehhez a konvolúciós rétegek kimenetét használja inputként, nem az eredeti képet. </p><p> </p><ul><li>Optikai karakterfelismerés: Az MI jelfeldolgozó és generalizációs képességeit kiaknázva képes </li></ul><p>magas hatékonysággal nyomtatott, papír alapú dokumentumokon lévő karaktereket felismerni.  </p><p> </p><p>Nehézségek:  </p><ul><li><ul><li>Nagy zajarány a papír alapú dokumentumoknál. Pl. apró folt a papíron, tinta elmosódás stb. </li><li>Kézírás még nehezebb a személyiségjegyek miatt </li><li>A nyomtatott latin karakterek felismerése megoldott problémának tekinthető, az OCR rendszerek hatékonyan képesek felismerni ezeket. </li><li>A kézírás felismerése azonban még napjainkban is aktív kutatási terület, hiszen ez jóval összetettebb feladat. </li></ul></li></ul><p> </p><ul><li><ol><li>Szegmentáció: Cél a karakterek közötti éles határ megtalálása annak érdekében, hogy téves minták ne kerüljenek osztályozásra. A szegmentáció feleadata lehet az is, hogy a karakter dőlésszöget, karakterméretet normalizálja. A további feladata, hogy kiszűrje a csak karaktereket tartalmazó szöveges részeket. </li><li>Optikai előfeldolgozás: A bemeneti minta komplexitásának csökkentésére szolgál, és annak legjellemzőbb vonásait emeli ki, ez a komplexitáscsökkentéssel járó digitalizáció. </li><li>Osztályozás: Pl. mesterséges neurális hálózattal történik. </li></ol></li></ul><p> </p><h1>Ajánlórendszerek alapjai és főbb kihívásai </h1><h2>Adatbányászat </h2><p>Az adatbázisból történő tudásfeltárás módszereknél alkalmazott technikák formájában fejlődött. A nagyméretű adatbázisokban való mintázatokkal és trendekkel kapcsolatos információkinyerés a cél. A leggyakoribb üzleti felhasználása a döntéstámogató rendszerek területén történik. </p><h2>Data Science </h2><p>A részének tekinthető az adatbányászat. Története 1960-as évekre vezethető vissza. A vállalati szférában jellemzően adatalapú szolgáltatások és rendszerek építésére használják. Számos más területhez is kapcsolódik. Pl. gépi tanulás. A terület művelőinek nem elegendő adatfeldolgozási és statisztikai ismeretekkel rendelkeznie. </p><h2>Big Data </h2><p>Fogalma alatt többet értünk, mint nagymennyiségű és összetettségű adatok kezelése. Beleértjük annak keletkezésének sebességét, valamint teljes környezetet, ami lehetővé teszi ezt. A szolgáltatásokhoz gyűjtött adatok köre nagy változatossággal és megbízhatósággal bírhat. Eltérő szemlélettel kezelendőek, mint a klasszikus adatbázisok és eltérő üzleti értékkel, valamint különböző felhasználhatósági lehetőségekkel rendelkeznek. Az utóbbi időben a hardver és szoftvertechnológiai megoldások fejlődésével a nagy adatok feldolgozása sem olyan jelentős kihívás. Ezzel szemben az MI területén belül a gépi tanulás és a mély neurális hálók különböző profilozó és adatelemző alkalmazásai, valamint a fuzzy technológiák alkalmazása az adatok és kapcsolatok leírására egyre nagyobb szerepet kapnak. </p><h2>Ajánlórendszerek </h2><p>Az ajánlórendszerek alkalmazása nem csak az üzleti döntéshozatal támogatására és a webes keresések finomítására szolgál. Az internet és az általa nyújtott szolgáltatások széles köre, mint pl. ez e-kereskedelem, híradás, vagy az on-demand szolgáltatások és a mobiltechnológia és egyéb IoT eszközök terjedése egyaránt hozzájárult az egyre inkább személyre és helyzetre szabott ajánlásokat adórendszerek fejlődéséhez. A korai ajánlórendszerek távoli kapcsolatban sem álltak az MI területtel. A megoldások és képességek nagyon szerények voltak. A központi cél megegyezik, termékek, tartalmak vagy szolgáltatások kiválasztása a felhasználók vagy fogyasztók részére oly módon, hogy az ajánlott termékek a lehető legnagyobb relevanciával rendelkezzenek. </p><p>A legkorábbi pl. webes értékesítő megoldásoknál alkalmazott ajánlási technikák valamilyen egyszerű hierarchikus modellen alapultak. Egy internetes könyváruház esetén a termékeket a könyvek képviselik, ezeket különböző szempontok, jellemzők szerint lehet hierarchikusan csoportosítani. Ha felépítettük a kívánt hierarchiát, akkor egy vásárló aktuálisan vásárolt könyvek jellemzői alapján könnyedén megkereshetőek a hierarchikus modellben reprezentálva közel álló további könyvek. </p><p>A modern ajánlórendszerek már nem statikus fastruktúrákkal és jelentősen bővebb adatkészlettel dolgozhatnak és egyre pontosabb, a személyre szabottabb ajánlások kiválasztása. </p><p>3 fő csoportba sorolhatóak az alkalmazott megközelítések: </p><ul><li>Kollaboratív szűrők </li><li>Tartalom alapú megközelítések </li><li>Ezek kombinációját használó hibrid modellek </li></ul><p> </p><p>Automata adatgyűjtő rendszerek: Különböző hírek, közösségi portálok bejegyzései, tőzsdei adatok begyűjtésére szolgáló egyszerűbb ágensek. A gyűjtött adatokat alapvetően két fő kategóriába sorolhatjuk: implicit és explicit adatokra. Különös jelentősége a különböző multimédiás tartalmak esetében van. Pl. egy videó képi és hangi tartalma alapján kell kigyűjteni annak jellemzőit, de akár szöveges tartalmak digitalizálását és annak érzelmi elemzését is elvégezhetik. Az ilyen feladatok elvégzése modern MI megoldások nélkül lehetetlen lenne. </p><p>Modellalkotás: Alapvetően a termékek és a felhasználók különböző aspektusban való leírására alkalmaznak modelleket. A modellek célja, hogy pontos képet tudjanak alkotnia fogyasztói szokásokról, preferenciákról, termékek jellemzőiről, azok kapcsolatairól az ajánlások finomítása érdekében. Nem léteznek univerzális modellek. </p><p>Főbb alkalmazási területek: </p><ul><li>Befektetési és egyéb üzleti szolgáltatások </li><li>Utazási és egyéb turisztikai ajánlások </li><li>Kis és nagy kereskedelem </li><li>Médiatartalmak </li><li>Hétköznapi és luxus ingóságok, ingatlanok </li><li>Társkeresés </li><li>Egészségügyi szolgáltatások </li><li>Pályaválasztási tanácsadás </li><li>Kompetencia mérésére szolgáló adaptív számonkérési rendszerek </li><li>Lakberendezési, életstílus tanácsadás </li><li>Hírek </li><li>Csoportos tevékenységek </li></ul><p> </p><p>Főbb kihívások: Az ajánlórendszerek korlátjai, működési elve és túlzott pontossága esetenként épp a céllal szemben komoly ellenszenvet válthat ki. Természetesen a legtöbb esetben a modern, tech óriások által használt algoritmusok a problémakör komplexitásához viszonyítva roppant nagy pontosságot tudnak elérni. </p><p>Kihívás még a kulcs kihívása, a felhasználói tevékenységek megfelelő értelmezése profitalkotás céljából. A visszajelzéseknek két kategóriája van:  </p><ul><li>Explicit visszajelzések: Pl. közvetlen felhasználói értékelések. Nagy pontossággal bírnak és pozitív, valamint negatív vélemény abszolút mérésére is képes, a begyűjtése nehéz. </li><li>Implicit visszajelzések: Tartalmak fogyasztása során gyűjtött adatok, pl. kattintás. Előnye, hogy könnyű begyűjteni, így nagyobb mennyiségben áll rendelkezésre. Hátrányahogy megbízhatatlan, relatív, kizárólag pozitív visszajelzési információk nyerhetőek ki, értelmezésük nehéz. </li></ul><p> </p><p>A profilalkotás számos kihívással bír még. Pl. a felhasználók preferenciáinak időbeli változása, ami vonatkozhat az ízlés változására, vagy egyéb szezonális hatásra. Nem csak hosszú távú, de rövid időbeni hatások is befolyásolják. Pl. egy adott napszak, vagy éppen használt eszköz. Egyes alkalmazások esetén jelentős kihívás a felhasználó megfelelő azonosítása. </p><h2>Ajánlórendszer fogalmak </h2><p>Hidegindítási (Cold-start) probléma: A kollaboratív szűrőkön alapuló megoldásokra jellemző jelentős gyakorlati kihívás. Olyan helyzeteket értjük alatta, amikor egy termékről, vagy felhasználóról nem rendelkezünk semmilyen információval, így azokat nem tudjuk csoportosítani. Pl. új termékek, vagy felhasználók megjelenésekor nagyobb hangsúlyt fektetnek a meta adatokra, itt részben a hidegindítási probléma megoldása motiválta a tartalomalapú szűrőket. </p><p>Rokonértelműség (Synonymy): Amikor kismértékben eltérő leírással rendelkező, vagy azonos, de az adatbázisban külön bejegyzésként szereplő termékeket kell kezelnie. A gyakori megoldások közé tartozik a termékek leírásainak részletes elemzése, de ez gyakran költséges, illetve esetenként kiszűrik a nagymértékben hasonló, de valójában különálló termékeket. Hibátlan, teljesen automatizált rendszer nem működik, gyakran igényel emberi beavatkozás.   </p><p>Telítettségi pont (Saturation point): Általánosságban elmondható, hogy több mintaadat révén pontosabb termék, vagy felhasználói modell alkotható, azonban elméletileg elérhető egy olyan állapot, melyet követően az új mintaadatok már nem tudnak szignifikánsan javítani a modellen. </p><p>Bemelegítési periódus (Warm-up): A hidegindítási fázis és a telítettségi pont közötti időszak. Minnél kevesebb minta révén érhető el a telítettségi pont, annál gyorsabban alkotható meg egy pontos modell, így több kutatás is ezt a problémát vizsgálja. </p><p>Szürkebárány (Gray Sheep): Az olyan felhasználók, akik visszajelzései kiszámíthatatlanok, egyetlen rendszerben tárolt felhasználói csoportnak sem feleltethetőek meg egyértelműen. </p><p>Feketebárány (Black Sheep): Az olyan felhasználók, akiknek annyira egyedi ízlésük van, hogy számukra a megfelelő ajánlás generálása szinte lehetetlen. </p><p>Szélhámosok támadása (Shilling Attack): A kollaboratív rendszerekre jellemző, ahol az egyes felhasználók tetszőlegesen értékelhetik a termékeket. Ezt kihasználva a rosszindulatú felhasználók a saját termékeiket számos pozitív értékeléssel látják el, míg a versenytársakét negatívakkal. </p><p>Skálázhatóság (Scalability): Gyakori szűk keresztmetszetet jelent az ajánlórendszerek számára. Sok módszer kiválóan működik egyszerűbb vizsgálatok során, azonban a valós piaci körülmények között már nem képesek hatékonyan kezelni az adatokat. A legtöbb szolgáltatás esetén közel valós időben kell az adatokat feldolgozni. Dimenzióredukciós módszerek segíthetnek csökkenteni a probléma méretét, de jellemzően költséges mátrix faktorizációs megoldásokról van szó. </p><p>Kollaboratív szűrés </p><p>A működési koncepciója, hogy az ajánlások más, jellemzően valamilyen szempont szerint hasonló, egy csoportba tartozó felhasználókkal kapcsolatos ismeretek alapján kerülnek meghatározásra, vagyis azzal a feltevéssel működnek, hogy más felhasználók korábbi fogyasztási hasonlósága alapján próbálja megjósolni az ideális terméket. </p><p>3 fő csoportja: 1. Memóriaalapú: A felhasználóktól gyűjtött termékértékelések alapján határozzák meg a termékek és felhasználók közötti hasonlóságot. A gyakorlati célú rendszerek körében az első megoldások közé tartoztak. A módszerek nagy előny, hogy könnyen implementálhatóak. Az adatokkal való bővítés könnyen kivitelezhető, nem kell figyelembe vennie a termékek tartalmi jellemzőit. Hátránya, hogy az ilyen rendszerek jellemzően explicit adatokra építenek, az adatok hiánya pedig nagyban befolyásolja az ajánlások jóságát. Új, ismeretlen felhasználók vagy termékek esetén nem tud ajánlást generálni. </p><p> </p><p>A módszerek 2 fő lépésre oszthatóak: </p><p>o Minták csoportosítása, vagyis a termékek vagy felhasználók csoportokba való sorolása o Ajánlási fázis, nincs modellépítés </p><p> </p><p>kNN módszer: Gyakran alkalmazzák a k legközelebbi szomszéd megoldást. Az egyes felhasználók, vagy termékek egy n dimenziós paraméter tér pontjaiként ábrázolhatók. Az így kapott ponthalmaz k darab csoportba sorolható. A cél, hogy megkeressük egy új adatpont számára azt a csoportot, amelyikbe a leginkább illeszkedik. Az alapfeltételezés, hogy minél kisebb a távolság a két adatpont között, annál nagyobb a valószínűsége, hogy azonos csoportba tartoznak. </p><p> </p><ol><li>Modellalapú: Az egyes termékekről és felhasználókról modellt készítünk az alapján, hogy az adott felhasználó milyen jellemzőket keres egy termékben, vagy egy termék milyen tulajdonságokat nyújt egy felhasználó számára. Az itt használt megoldások jellemzően összetettebbek, gyakran valamilyen dimenzióredukciós technikát alkalmaznak. Lényegében a memória alapú megoldásoknál használt információt tömörítjük a dimenzió redukció révén, így kisebb adathalmazzal dolgozhatunk. Előnye a memóriaalapú megoldásokkal szemben, hogy pontosabb és hatékonyabb ajánlásokat generál, könnyebben kezeli a hiányos adatokat és skálázhatóbb. Hátránya, hogy a modellalkotási folyamat erőforrás igényes, a skálázás mértéke és a hatékonyság között fordított kapcsolat áll fent. Egyes implementációk eltérhetnek az alkalmazott módszerekben, mint pl. a különböző klaszterezési megoldásokban. A klaszterezési technikákat alkalmazó modellalapú kollaboratív szűrők eseténa kközép vagy annak a fuzzy változata, a fuzzy c-közép a leggyakoribb példa. A cél, hogy n darab megfigyelést, vagy adatpontot k darab klaszterbe vagy csoportba soroljunk. </li></ol><p> </p><p>Fő lépések: </p><ul><li><ul><li><ul><li>Klaszterek középpontjainak inicializálása, amíg a konvergencia nem áll fent o Minden adatpont hozzárendelése a legközelebbi klaszterközépponthoz. o Az azonos klaszterbe sorolt adatpontok alapján új klaszterközéppont meghatározása A klaszterközéppontok kezdeti inicializációja véletlenszerűen, míg a harmadik lépésben az azonos klaszterbe tartozó adatpontok valamilyen középértéke alapján történik. Hátránya, hogy a lokális optimum felé viszi a megoldást, a kezdeti klaszterközéppontok kiválasztásától nagyban függ a megoldás kimenete és a klaszterek számát előre ismernünk kell. A k közép algoritmus gyakorlatilag egy nemfelügyelt tanulásnak tekinthető. </li></ul></li></ul></li></ul><p> </p><p>Funk SVD: Simon Funk nevéhez köthető, a modellalapú megközelítések esetén az egyik leggyakrabban használt megoldások a mátrix faktorizációra épülnek.  Lényege az alábbi módon fogalmazható meg: </p><ul><li><ul><li><ul><li>A felhasználók és termékekre adott értékeléseik egy ritka mátrixban találhatóak meg. o Felbontható két másik mátrix szorzatára </li><li>Ekkora a felbontás eredményeként kapott két mátrix a felhasználói mátrix és a termék mátrix, melyek mérete kisebb lesz az eredeti értékelési mátrixénál és a hiányzó adatok is eltűnnek </li><li>A felhasználói és a termék mátrixok ekkor ún. látens jellemzőket tartalmaznak </li><li>Természetesen több lehetséges felhasználói és termék mátrix létezhet, ami a ritka értékelési </li></ul></li></ul></li></ul><p>mátrixra illeszkedik </p><ol><li>Hibrid megoldások: A legtöbb piaci alkalmazással rendelkező kollaboratív szűrést alkalmazó ajánlórendszer valamilyen hibrid megoldást alkalmaz. A két fő megközelítés, a modell és memória alapú módszerek ötvözése, a másik a kollaboratív szűrési eljárásokat tartalom alapú információk erősítésével ötvözve. Gyengeségek kiküszöbölése, mint a ritka, hiányos, elveszett adatok. Komoly hátránya az efféle megoldásoknak, hogy bonyolultabbak így implementálásuk is nehezebb. </li></ol><p> </p><p>Működési elve: </p><ul><li>k értéket kiválasztjuk </li><li>Minden egyes ismert adatpontra az ismeretlen és az ismert adatpontok közötti távolságmérték meghatározása. </li><li>Az ismert adatpontok sorba rendezése a távolságmérték alapján, majd a legjobb k darab adatpontot kiválasztjuk. </li><li>A kiválasztott k darab ismert adatponthoz rendelt leggyakoribb csoportot kiválasztva visszatérünk </li></ul><p>azzal, mint az ismeretlen adatpont osztálya. </p><p> </p><p><strong>Tartalomalapú szűrés </strong>Az egyes termékekkel kapcsolatos leírások és egyéb alapadatok állhatnak rendelkezésre a felhasználói profilon túl. Különösképp olyan helyzetekben alkalmazzák, amikor a termékekről kiterjedt adatokkal rendelkezhetnek, azonban a felhasználókról egyáltalán nem, vagy korlátozottan. Az ilyen rendszerek alapvetően a felhasználó korábbi választásai alapján ajánl azokhoz nagyon hasonló termékeket. Az értékelési mátrixot a kollaboratív szűrésen alapuló technikákhoz hasonlóan itt is felbontják a felhasználói és termékvektorokra. Az egyes termékvektorok tartalmazzák az azokat leíró jellemzőket, amely alapján összehasonlíthatóak. Az ajánlások a felhasználói és termékvektorok koszinusz hasonlósága alapján kerülnek meghatározásra. </p><p>Előnye: A hidegindítási problémára megoldást nyújtanak, mivel alacsony szintű, alapadatokra építik az ajánlásokat és a modellek finomítására jellemzően meta adatokat használnak. </p><p>Hátránya: Nem generálnak kellően változatos, vagy új tartalmakat a felhasználók számára. Alapvetően a korábbi, ismert preferenciákhoz nagyon hasonló termékeket ajánlják, nem segítik a felhasználókat a tartalmak felfedezésében. </p><p><strong>Hibrid szűrés:  </strong></p><p>A hibrid szűrésen alapuló megoldásokat jellemzően valamilyen CF és CBF módszereket alkalmaznak. Párhuzamosan határozzák meg az ajánlásokat. Egy külön egység hozza meg a végső ajánlásokat. Az ilyen megoldások hátránya, hogy jelentős az erőforrásigényük. </p><p> </p><p> </p>
            </div>
        </main>
    );
}